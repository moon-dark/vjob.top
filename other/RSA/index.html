<!doctype html><html lang=zh class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=http://vjob.top/other/RSA/ rel=canonical><link rel=icon href=../../assets/images/favicon.png><meta name=generator content="mkdocs-1.2.3, mkdocs-material-8.2.1"><title>RSA - 微站</title><link rel=stylesheet href=../../assets/stylesheets/main.e8d9bf0c.min.css><link rel=stylesheet href=../../assets/stylesheets/palette.e6a45f82.min.css><meta name=theme-color content=#ffffff><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Noto+Sans:300,400,400i,700%7CSource+Code+Pro&display=fallback"><style>:root{--md-text-font:"Noto Sans";--md-code-font:"Source Code Pro"}</style><script>__md_scope=new URL("../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=preference data-md-color-primary=white data-md-color-accent=red> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#_1 class=md-skip> 跳转至 </a> </div> <div data-md-component=announce> </div> <header class="md-header md-header--lifted" data-md-component=header> <nav class="md-header__inner md-grid" aria-label=页眉> <a href=../.. title=微站 class="md-header__button md-logo" aria-label=微站 data-md-component=logo> <img src=../../img/avatar.png alt=logo> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> 微站 </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> RSA </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=搜索 placeholder=搜索 autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </label> <nav class=md-search__options aria-label=查找> <a href=javascript:void(0) class="md-search__icon md-icon" aria-label=分享 data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08z"/></svg> </a> <button type=reset class="md-search__icon md-icon" aria-label=清空当前内容 tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg> </button> </nav> <div class=md-search__suggest data-md-component=search-suggest></div> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> 正在初始化搜索引擎 </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> </nav> <nav class=md-tabs aria-label=标签 data-md-component=tabs> <div class="md-tabs__inner md-grid"> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../.. class=md-tabs__link> 主页 </a> </li> <li class=md-tabs__item> <a href=../../RPI/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85Ubuntu%20mate15.10-%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0_machh%E7%9A%84%E4%B8%93%E6%A0%8F-CSDN%E5%8D%9A%E5%AE%A2/ class=md-tabs__link> 树莓派 </a> </li> <li class=md-tabs__item> <a href=../../Android/Android10%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD/ class=md-tabs__link> Android </a> </li> <li class=md-tabs__item> <a href=../../Bash/%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84Linux%E6%8A%80%E5%B7%A7/ class=md-tabs__link> Bash </a> </li> <li class=md-tabs__item> <a href=../CTF%E5%B8%B8%E7%94%A8RSA%E6%8A%80%E5%B7%A7/ class="md-tabs__link md-tabs__link--active"> 安全 </a> </li> <li class=md-tabs__item> <a href=../How%20to%20Get%20Rich/ class=md-tabs__link> 其它 </a> </li> </ul> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=导航栏 data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../.. title=微站 class="md-nav__button md-logo" aria-label=微站 data-md-component=logo> <img src=../../img/avatar.png alt=logo> </a> 微站 </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_1 type=checkbox id=__nav_1> <label class=md-nav__link for=__nav_1> 主页 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=主页 data-md-level=1> <label class=md-nav__title for=__nav_1> <span class="md-nav__icon md-icon"></span> 主页 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../.. class=md-nav__link> 微站 </a> </li> <li class=md-nav__item> <a href=../../RPI/%E7%A1%AC%E7%9B%98%E5%90%AF%E5%8A%A8%E6%A0%91%E8%8E%93%E6%B4%BE%EF%BC%93B/ class=md-nav__link> 树莓派 </a> </li> <li class=md-nav__item> <a href=../../Android/Android10%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD/ class=md-nav__link> Android </a> </li> <li class=md-nav__item> <a href=../../Bash/%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84Linux%E6%8A%80%E5%B7%A7/ class=md-nav__link> Bash </a> </li> <li class=md-nav__item> <a href=../../Android/Mobile%20Application%20Penetration%20Testing%20Cheat%20sheet%20with%20Tools%20%26%20Resources/ class=md-nav__link> 安全 </a> </li> <li class=md-nav__item> <a href=../How%20to%20Get%20Rich/ class=md-nav__link> 其它 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_2 type=checkbox id=__nav_2> <label class=md-nav__link for=__nav_2> 树莓派 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=树莓派 data-md-level=1> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> 树莓派 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../RPI/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85Ubuntu%20mate15.10-%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0_machh%E7%9A%84%E4%B8%93%E6%A0%8F-CSDN%E5%8D%9A%E5%AE%A2/ class=md-nav__link> 树莓派安装Ubuntu mate15.10 系统笔记 machh的专栏 CSDN博客 </a> </li> <li class=md-nav__item> <a href=../../RPI/%E7%A1%AC%E7%9B%98%E5%90%AF%E5%8A%A8%E6%A0%91%E8%8E%93%E6%B4%BE%EF%BC%93B/ class=md-nav__link> 硬盘启动树莓派３B </a> </li> <li class=md-nav__item> <a href=../../RPI/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85JDK/ class=md-nav__link> 树莓派安装JDK </a> </li> <li class=md-nav__item> <a href=../../RPI/%E5%B0%86%E6%A0%91%E8%8E%93%E6%B4%BERaspberry%20Pi%E8%AE%BE%E7%BD%AE%E4%B8%BA%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%28WiFi%E7%83%AD%E7%82%B9AP%2CRTL8188CUS%E8%8A%AF%E7%89%87%29/ class=md-nav__link> 将树莓派Raspberry Pi设置为无线路由器(WiFi热点AP,RTL8188CUS芯片) </a> </li> <li class=md-nav__item> <a href=../../RPI/Using%20Raspberry%20Pi%20for%20Laravel%20developing/ class=md-nav__link> Using Raspberry Pi for Laravel developing </a> </li> <li class=md-nav__item> <a href=../../RPI/VNC%20setup%20on%20Raspberry%20Pi%20from%20Ubuntu/ class=md-nav__link> VNC setup on Raspberry Pi from Ubuntu </a> </li> <li class=md-nav__item> <a href=../../RPI/%E8%AE%BE%E7%BD%AE%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E5%A4%96%E7%BD%AE%E7%A1%AC%E7%9B%98%E5%90%AF%E5%8A%A8/ class=md-nav__link> 设置树莓派使用外置硬盘启动 </a> </li> <li class=md-nav__item> <a href=../../RPI/%E6%8A%8A%E6%A0%91%E8%8E%93%E6%B4%BE%E5%8F%98%E6%88%9024%E5%B0%8F%E6%97%B6%E8%BF%90%E8%A1%8C%E7%9A%84%E4%B8%8B%E8%BD%BD%E7%A5%9E%E5%99%A8%EF%BC%88%E7%A7%8D%E5%AD%90%E3%80%81%E7%A3%81%E5%8A%9B%E9%93%BE%E9%80%9A%E9%80%9A%E6%94%AF%E6%8C%81%EF%BC%89/ class=md-nav__link> 把树莓派变成24小时运行的下载神器（种子、磁力链通通支持） </a> </li> <li class=md-nav__item> <a href=../../RPI/%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE2%E4%B8%8A%E5%AE%89%E8%A3%85%20Chromium%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%8A%20Google%20%E6%8B%BC%E9%9F%B3%E8%BE%93%E5%85%A5%E6%B3%95/ class=md-nav__link> 在树莓派2上安装 Chromium 浏览器及 Google 拼音输入法 </a> </li> <li class=md-nav__item> <a href=../../RPI/%E4%B8%BA%E6%A0%91%E8%8E%93%E6%B4%BEDIY%E4%B8%80%E6%AC%BE%E9%AB%98%E9%80%9F%E7%A8%B3%E5%AE%9A%E7%9A%84%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1/ class=md-nav__link> 为树莓派DIY一款高速稳定的无线网卡 </a> </li> <li class=md-nav__item> <a href=../../RPI/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B6%E2%80%94%E2%80%94%E6%A0%91%E8%8E%93%E6%B4%BE%E5%81%9Awifi%E7%83%AD%E7%82%B9_%E8%80%81%E5%BE%902014-CSDN%E5%8D%9A%E5%AE%A2_%E6%A0%91%E8%8E%93%E6%B4%BE%E5%81%9Awifi%E7%83%AD%E7%82%B9/ class=md-nav__link> 树莓派开发系列教程6——树莓派做wifi热点 老徐2014 CSDN博客 树莓派做wifi热点 </a> </li> <li class=md-nav__item> <a href=../../RPI/%E6%A0%91%E8%8E%93%E6%B4%BEwifi%E7%A0%B4%E8%A7%A3%E6%95%B4%E7%90%86%20-%20FindHao/ class=md-nav__link> 树莓派wifi破解整理 FindHao </a> </li> <li class=md-nav__item> <a href=../../RPI/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%A6%99%E6%A9%99%E6%B4%BE%E6%97%A0%E7%BA%BF%E6%92%AD%E6%94%BE%EF%BC%8C%E5%AE%9E%E7%8E%B0DLNA%E4%B8%8EAirPlay%E5%8D%8F%E8%AE%AE%E6%97%A0%E7%BA%BF%E9%9F%B3%E7%AE%B1/ class=md-nav__link> 树莓派香橙派无线播放，实现DLNA与AirPlay协议无线音箱 </a> </li> <li class=md-nav__item> <a href=../../RPI/SSH%E9%80%9A%E8%BF%87%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5/ class=md-nav__link> SSH通过代理连接 </a> </li> <li class=md-nav__item> <a href=../../RPI/Autossh%20and%20Systemd%20Service/ class=md-nav__link> Autossh and Systemd Service </a> </li> <li class=md-nav__item> <a href=../../RPI/Copying%20MySQL%20Databases%20to%20Another%20Machine/ class=md-nav__link> Copying MySQL Databases to Another Machine </a> </li> <li class=md-nav__item> <a href=../../RPI/How%20To%20Move%20a%20MySQL%20Data%20Directory%20to%20a%20New%20Location%20on%20Ubuntu%2016.04/ class=md-nav__link> How To Move a MySQL Data Directory to a New Location on Ubuntu 16.04 </a> </li> <li class=md-nav__item> <a href=../../RPI/Latest%20Version%20of%20Firefox%20and%20Thunderbird%20on%20a%20Raspberry%20Pi%20%5Bobsolete%5D/ class=md-nav__link> Latest Version of Firefox and Thunderbird on a Raspberry Pi [obsolete] </a> </li> <li class=md-nav__item> <a href=../../RPI/OpenWrt%20%E4%BD%BF%E7%94%A8%20frp%20%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%20%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%20%E6%96%87%E7%AB%A0%E8%AF%84%E8%AE%BA/ class=md-nav__link> OpenWrt 使用 frp 实现内网穿透 准备工作 搭建内网穿透 文章评论 </a> </li> <li class=md-nav__item> <a href=../../RPI/%E8%A7%A3%E5%86%B3%E6%A0%91%E8%8E%93%E6%B4%BESSH%E7%99%BB%E5%BD%95%E7%BC%93%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98_Maoning%20Guan%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2/ class=md-nav__link> 解决树莓派SSH登录缓慢的问题 Maoning Guan的博客 CSDN博客 </a> </li> <li class=md-nav__item> <a href=../../RPI/Reading%20privileged%20memory%20with%20a%20side-channel/ class=md-nav__link> Reading privileged memory with a side channel </a> </li> <li class=md-nav__item> <a href=../../RPI/Install%20Latest%20ReadyMedia%20miniDLNA%20Raspberry%20Pi/ class=md-nav__link> Install Latest ReadyMedia miniDLNA Raspberry Pi </a> </li> <li class=md-nav__item> <a href=../../RPI/%E4%BD%BF%E7%94%A8%20vcgencmd%20%E6%8C%87%E4%BB%A4%E6%9F%A5%E7%9C%8B%20Raspberry%20Pi%20%E7%9A%84%20CPU%20%E6%BA%AB%E5%BA%A6%E3%80%81%E9%81%8B%E8%A1%8C%E9%80%9F%E5%BA%A6%E8%88%87%E9%9B%BB%E5%A3%93%E7%AD%89%E8%B3%87%E8%A8%8A/ class=md-nav__link> 使用 vcgencmd 指令查看 Raspberry Pi 的 CPU 溫度、運行速度與電壓等資訊 </a> </li> <li class=md-nav__item> <a href=../../RPI/Aria2%20%E7%BC%96%E8%AF%91%20%E6%B7%BB%E5%8A%A0%E6%94%AF%E6%8C%81BT%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%88X86%E5%92%8Carmhf%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE2%EF%BC%89/ class=md-nav__link> Aria2 编译 添加支持BT下载的功能（X86和armhf的树莓派2） </a> </li> <li class=md-nav__item> <a href=../../RPI/Let%27s%20Encrypt%EF%BC%8C%E5%85%8D%E8%B4%B9%E5%A5%BD%E7%94%A8%E7%9A%84%20HTTPS%20%E8%AF%81%E4%B9%A6/ class=md-nav__link> Let's Encrypt，免费好用的 HTTPS 证书 </a> </li> <li class=md-nav__item> <a href=../../RPI/%E4%BD%BF%E7%94%A8SSH%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/ class=md-nav__link> 使用SSH反向隧道进行内网穿透 </a> </li> <li class=md-nav__item> <a href=../../RPI/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%A9%E7%94%A8nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%8C%E6%88%90%E4%B8%BAIPv6_IPv4%E5%85%AC%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E9%9C%80%E8%A6%81%E8%BF%9C%E7%A8%8B%E5%8F%8C%E6%A0%88%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89/ class=md-nav__link> 树莓派利用nginx反向代理，成为IPv6 IPv4公网服务器（需要远程双栈服务器） </a> </li> <li class=md-nav__item> <a href=../../RPI/%E5%A6%82%E4%BD%95%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E6%90%AD%E5%BB%BA%20WordPress/ class=md-nav__link> 如何在树莓派上搭建 WordPress </a> </li> <li class=md-nav__item> <a href=../../RPI/Install%20Redis%20on%20your%20Raspberry%20Pi/ class=md-nav__link> Install Redis on your Raspberry Pi </a> </li> <li class=md-nav__item> <a href=../../RPI/%E6%A0%91%E8%8E%93%E6%B4%BE4%E5%8F%98%E8%BA%AB%E6%97%81%E8%B7%AF%E7%94%B1/ class=md-nav__link> 树莓派4变身旁路由 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_3 type=checkbox id=__nav_3> <label class=md-nav__link for=__nav_3> Android <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Android data-md-level=1> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> Android </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../Android/Android10%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD/ class=md-nav__link> Android10源码下载 </a> </li> <li class=md-nav__item> <a href=../../Android/%E5%B1%8F%E5%B9%95%E5%9D%8F%E4%B8%80%E5%8A%A0%E6%89%8B%E6%9C%BA%E5%88%B7android10/ class=md-nav__link> 屏幕坏一加手机刷android10 </a> </li> <li class=md-nav__item> <a href=../../Android/Enable%20ADB%20from%20recovery/ class=md-nav__link> Enable ADB from recovery </a> </li> <li class=md-nav__item> <a href=../../Android/Android%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E5%92%8Croot%E6%9D%83%E9%99%90/ class=md-nav__link> Android系统权限和root权限 </a> </li> <li class=md-nav__item> <a href=../../Android/%E3%80%90Android%20ROM%E5%AE%9A%E5%88%B6%E3%80%91CyanogenMod%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E5%92%8C%E7%BC%96%E8%AF%91/ class=md-nav__link> 【Android ROM定制】CyanogenMod源码下载和编译 </a> </li> <li class=md-nav__item> <a href=../../Android/android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/ class=md-nav__link> Android内存泄露优化总结 </a> </li> <li class=md-nav__item> <a href=../../Android/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF%EF%BC%9AProguard%E8%BF%9B%E8%A1%8C%E6%BA%90%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E5%92%8C%E5%B4%A9%E6%BA%83%E6%97%A5%E5%BF%97%E5%8F%8D%E6%B7%B7%E6%B7%86/ class=md-nav__link> 日积月累：Proguard进行源代码混淆和崩溃日志反混淆 </a> </li> <li class=md-nav__item> <a href=../../Android/10%20Ways%20to%20Improve%20Your%20Android%20App%27s%20Performance/ class=md-nav__link> 10 Ways to Improve Your Android App's Performance </a> </li> <li class=md-nav__item> <a href=../../Android/Anatomy%20of%20RecyclerView%3Aa%20Search%20for%20a%20ViewHolder/ class=md-nav__link> Anatomy of RecyclerView:a Search for a ViewHolder </a> </li> <li class=md-nav__item> <a href=../../Android/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94Hook%E6%9C%BA%E5%88%B6%E4%B9%8BBinder%20Hook/ class=md-nav__link> Android插件化原理解析——Hook机制之Binder Hook </a> </li> <li class=md-nav__item> <a href=../../Android/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%BD%93%E5%BE%AE%E4%BF%A1%E8%BF%90%E5%8A%A8%E7%AC%AC%E4%B8%80%E5%90%8D%E2%80%93%E5%88%A9%E7%94%A8AndroidHook%E8%BF%9B%E8%A1%8C%E5%BE%AE%E4%BF%A1%E8%BF%90%E5%8A%A8%E4%BD%9C%E5%BC%8A/ class=md-nav__link> 手把手教你当微信运动第一名–利用AndroidHook进行微信运动作弊 </a> </li> <li class=md-nav__item> <a href=../../Android/%E9%BB%91%E5%AE%A2%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E4%B8%89%E6%98%9F%E9%A2%84%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9D%A5%E7%9B%91%E8%A7%86%E7%94%A8%E6%88%B7/ class=md-nav__link> 黑客可以利用三星预装的应用程序来监视用户 </a> </li> <li class=md-nav__item> <a href=../../Android/Android%20%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93%20Android%20%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/ class=md-nav__link> Android 动画总结 Android 动画总结 </a> </li> <li class=md-nav__item> <a href=../../Android/Android%E7%AD%BE%E5%90%8D%E6%80%BB%E7%BB%93/ class=md-nav__link> Android签名总结 </a> </li> <li class=md-nav__item> <a href=../../Android/Am%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95/ class=md-nav__link> Am命令用法 </a> </li> <li class=md-nav__item> <a href=../../Android/10%20Tips%20for%20using%20the%20Eclipse%20Memory%20Analyzer/ class=md-nav__link> 10 Tips for using the Eclipse Memory Analyzer </a> </li> <li class=md-nav__item> <a href=../../Android/android%E4%BD%BF%E7%94%A8ndk-stack%E8%B0%83%E8%AF%95JNI%E9%83%A8%E5%88%86%E7%9A%84C_C%2B%2B%E4%BB%A3%E7%A0%81/ class=md-nav__link> android使用ndk stack调试JNI部分的C C++代码 </a> </li> <li class=md-nav__item> <a href=../../Android/NativeActivity%E5%8E%9F%E7%90%86/ class=md-nav__link> NativeActivity原理 </a> </li> <li class=md-nav__item> <a href=../../Android/Using%20data%20binding%20in%20Android/ class=md-nav__link> Using data binding in Android </a> </li> <li class=md-nav__item> <a href=../../Android/Android%E4%B8%8AWebRTC%E4%BB%8B%E7%BB%8D/ class=md-nav__link> Android上WebRTC介绍 </a> </li> <li class=md-nav__item> <a href=../../Android/CoordinatorLayout%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95-%E8%87%AA%E5%AE%9A%E4%B9%89Behavior/ class=md-nav__link> CoordinatorLayout高级用法 自定义Behavior </a> </li> <li class=md-nav__item> <a href=../../Android/OpenSSL%E5%AE%9E%E8%B7%B5-Android%E4%B8%8B%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E4%BD%BF%E7%94%A8/ class=md-nav__link> OpenSSL实践 Android下的编译和使用 </a> </li> <li class=md-nav__item> <a href=../../Android/%E4%BD%BF%E7%94%A8ShareSDK%E5%AE%8C%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%EF%BC%88QQ%E3%80%81%E5%BE%AE%E4%BF%A1%E3%80%81%E5%BE%AE%E5%8D%9A%EF%BC%89%E7%99%BB%E5%BD%95%E5%92%8C%E5%88%86%E4%BA%AB/ class=md-nav__link> 使用ShareSDK完成第三方（QQ、微信、微博）登录和分享 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_4 type=checkbox id=__nav_4> <label class=md-nav__link for=__nav_4> Bash <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Bash data-md-level=1> <label class=md-nav__title for=__nav_4> <span class="md-nav__icon md-icon"></span> Bash </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../Bash/%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84Linux%E6%8A%80%E5%B7%A7/ class=md-nav__link> 应该知道的Linux技巧 </a> </li> <li class=md-nav__item> <a href=../../Bash/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%9ATmux%20%E7%BB%88%E7%AB%AF%E5%A4%8D%E7%94%A8/ class=md-nav__link> 优雅地使用命令行：Tmux 终端复用 </a> </li> <li class=md-nav__item> <a href=../../Bash/%E6%88%91%E7%9A%84ImageMagick%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/ class=md-nav__link> 我的ImageMagick使用心得 </a> </li> <li class=md-nav__item> <a href=../../Bash/gdbcomm/ class=md-nav__link> Gdbcomm </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_5 type=checkbox id=__nav_5 checked> <label class=md-nav__link for=__nav_5> 安全 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=安全 data-md-level=1> <label class=md-nav__title for=__nav_5> <span class="md-nav__icon md-icon"></span> 安全 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../CTF%E5%B8%B8%E7%94%A8RSA%E6%8A%80%E5%B7%A7/ class=md-nav__link> CTF常用RSA技巧 </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" data-md-toggle=toc type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> RSA <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> RSA </a> <nav class="md-nav md-nav--secondary" aria-label=目录> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#_1 class=md-nav__link> 常用工具 </a> <nav class=md-nav aria-label=常用工具> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_2 class=md-nav__link> 分解大素数 </a> </li> <li class=md-nav__item> <a href=#sagehttpssagecellsagemathorg class=md-nav__link> 在线sage环境：https://sagecell.sagemath.org/ </a> </li> <li class=md-nav__item> <a href=#openssl class=md-nav__link> Openssl </a> </li> <li class=md-nav__item> <a href=#_3 class=md-nav__link> 脚本集 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_4 class=md-nav__link> 常见类型 </a> <nav class=md-nav aria-label=常见类型> <ul class=md-nav__list> <li class=md-nav__item> <a href=#pqec class=md-nav__link> 给p,q,e,c </a> </li> <li class=md-nav__item> <a href=#nedpc class=md-nav__link> 给n,e,dp,c </a> </li> <li class=md-nav__item> <a href=#pqdpdqc class=md-nav__link> 给p,q,dp,dq,c </a> </li> <li class=md-nav__item> <a href=#edwiener-attack class=md-nav__link> 低解密指数攻击/低私钥指数攻击（e长度较大，d小，Wiener Attack） </a> </li> <li class=md-nav__item> <a href=#hastad class=md-nav__link> 低加密指数广播攻击（Hastad攻击） </a> </li> <li class=md-nav__item> <a href=#nmce class=md-nav__link> 共模攻击（n,m相同，c,e不同） </a> </li> <li class=md-nav__item> <a href=#emnngcd class=md-nav__link> e,m相同，多个n中存在两个n有GCD（模不互素） </a> </li> <li class=md-nav__item> <a href=#rabin class=md-nav__link> Rabin加密 </a> </li> <li class=md-nav__item> <a href=#boneh-and-durfee-attack class=md-nav__link> Boneh and Durfee attack </a> </li> <li class=md-nav__item> <a href=#coppersmithp class=md-nav__link> Coppersmith攻击（已知p的高位攻击） </a> </li> <li class=md-nav__item> <a href=#coppersmithm class=md-nav__link> Coppersmith攻击（已知m的高位攻击） </a> </li> <li class=md-nav__item> <a href=#coppersmithd class=md-nav__link> Coppersmith攻击（已知d的低位攻击） </a> </li> <li class=md-nav__item> <a href=#coppersmithnp class=md-nav__link> Coppersmith攻击（已知N一个因子的高位，部分p） </a> </li> <li class=md-nav__item> <a href=#coppersmiths-short-pad-attack-related-message-attackfranklin-reiter class=md-nav__link> Coppersmith’s Short-pad Attack &amp; Related Message Attack（Franklin-Reiter攻击） </a> </li> <li class=md-nav__item> <a href=#rsa-hastad-attack-with-non-linear-padding-and-different-public-keyspadding class=md-nav__link> RSA Hastad Attack with non-linear padding and different public keys（带非线性padding和不同公钥的广播攻击） </a> </li> <li class=md-nav__item> <a href=#least-significant-bit-oracle-attack-lsb-oracle-attack-parity-oracle class=md-nav__link> Least Significant Bit Oracle Attack （LSB Oracle Attack / Parity Oracle） </a> </li> <li class=md-nav__item> <a href=#common-private-exponentd class=md-nav__link> Common Private Exponent（共私钥指数攻击，d相同） </a> </li> <li class=md-nav__item> <a href=#_5 class=md-nav__link> 多组低解密指数攻击 </a> </li> <li class=md-nav__item> <a href=#rsa class=md-nav__link> 多项式RSA </a> </li> <li class=md-nav__item> <a href=#weak-prime-factors-p class=md-nav__link> Weak prime factors （p具线性特征） </a> </li> <li class=md-nav__item> <a href=#_6 class=md-nav__link> 其他特别情形 </a> <nav class=md-nav aria-label=其他特别情形> <ul class=md-nav__list> <li class=md-nav__item> <a href=#multi-prime-rsa class=md-nav__link> 多素数因子（Multi-prime RSA） </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_7 class=md-nav__link> 详细原理 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../SageMath%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/ class=md-nav__link> SageMath常用函数 </a> </li> <li class=md-nav__item> <a href=../../Android/Mobile%20Application%20Penetration%20Testing%20Cheat%20sheet%20with%20Tools%20%26%20Resources/ class=md-nav__link> Mobile Application Penetration Testing Cheat sheet with Tools & Resources </a> </li> <li class=md-nav__item> <a href=../Most%20Important%20Network%20Penetration%20Testing%20Tools%20for%20Hackers%20%26%20Security%20Professionals/ class=md-nav__link> Most Important Network Penetration Testing Tools for Hackers & Security Professionals </a> </li> <li class=md-nav__item> <a href=../%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/ class=md-nav__link> 缓冲区溢出攻击实验 </a> </li> <li class=md-nav__item> <a href=../%E5%B7%A7%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/ class=md-nav__link> 巧用命令注入的N种方式 </a> </li> <li class=md-nav__item> <a href=../Smashing%20the%20Stack%20for%20Fun%20and%20Profit%20by%20Aleph%20One/ class=md-nav__link> Smashing the Stack for Fun and Profit by Aleph One </a> </li> <li class=md-nav__item> <a href=../../Android/Bad%20Binder%3AAndroid%20In-The-Wild%20Exploit/ class=md-nav__link> Bad Binder:Android In The Wild Exploit </a> </li> <li class=md-nav__item> <a href=../%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%99%E7%82%B9%E6%94%B6%E9%9B%86/ class=md-nav__link> 信息安全站点收集 </a> </li> <li class=md-nav__item> <a href=../%E7%8E%8B%E5%AD%90%E4%BA%AD%E7%9A%84%E5%8D%9A%E5%AE%A2%20GPG%20%E4%B8%8E%E7%AB%AF%E5%88%B0%E7%AB%AF%E5%8A%A0%E5%AF%86%EF%BC%9A%E8%AE%BA%E4%BB%80%E4%B9%88%E6%89%8D%E6%98%AF%E5%8F%AF%E4%BB%A5%E4%BF%A1%E4%BB%BB%E7%9A%84/ class=md-nav__link> 王子亭的博客 GPG 与端到端加密：论什么才是可以信任的 </a> </li> <li class=md-nav__item> <a href=../nc%3A%20invalid%20option%20%E2%80%94%20%E2%80%98-%E2%80%98/ class=md-nav__link> Nc: invalid option — ‘ ‘ </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_6 type=checkbox id=__nav_6> <label class=md-nav__link for=__nav_6> 其它 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=其它 data-md-level=1> <label class=md-nav__title for=__nav_6> <span class="md-nav__icon md-icon"></span> 其它 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../How%20to%20Get%20Rich/ class=md-nav__link> How to Get Rich </a> </li> <li class=md-nav__item> <a href=../TOP%2011%20Deep%20Web%20Search%20Engine%20Alternative%20for%20Google%20and%20Bing%202021/ class=md-nav__link> TOP 11 Deep Web Search Engine Alternative for Google and Bing 2021 </a> </li> <li class=md-nav__item> <a href=../FFmpeg%E5%8A%9F%E8%83%BD%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/ class=md-nav__link> FFmpeg功能命令汇总 </a> </li> <li class=md-nav__item> <a href=../%E4%B8%8D%E6%80%95%E5%A5%B8%E5%95%86%20%E6%8F%AD%E5%90%84%E5%93%81%E7%89%8C%E7%94%B5%E8%A7%86%E8%BF%9B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%96%B9%E6%B3%95/ class=md-nav__link> 不怕奸商 揭各品牌电视进工厂模式方法 </a> </li> <li class=md-nav__item> <a href=../%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/ class=md-nav__link> 傅里叶变换 </a> </li> <li class=md-nav__item> <a href=../%E6%BB%A4%E6%B3%A2%E5%99%A8/ class=md-nav__link> 滤波器 </a> </li> <li class=md-nav__item> <a href=../%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E7%AE%80%E4%BB%8B/ class=md-nav__link> 蓝牙协议入门（一）简介 </a> </li> <li class=md-nav__item> <a href=../%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/ class=md-nav__link> 蓝牙协议入门（二）传输层协议 </a> </li> <li class=md-nav__item> <a href=../%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%AD%E4%BB%8B%E5%B1%82%E5%8D%8F%E8%AE%AE/ class=md-nav__link> 蓝牙协议入门（三）中介层协议 </a> </li> <li class=md-nav__item> <a href=../%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/ class=md-nav__link> 蓝牙协议入门（四）应用层协议 </a> </li> <li class=md-nav__item> <a href=../TarsosDSP%20%E7%AE%80%E4%BB%8B%203.TarsosDSP%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F/ class=md-nav__link> TarsosDSP 简介 3.TarsosDSP 是如何工作的？ </a> </li> <li class=md-nav__item> <a href=../../tmp/%E5%AE%9E%E6%88%98rfc5766-turn-server%E5%92%8Cice4j%E5%B9%BF%E5%9F%9F%E7%BD%91%E9%80%9A%E8%AE%AF/ class=md-nav__link> 实战rfc5766 turn server和ice4j广域网通讯 </a> </li> <li class=md-nav__item> <a href=../%E6%B3%A2%E9%BB%91%E5%9B%B4%E5%9F%8E%E6%88%98%E4%B8%AD%E7%9A%84%E5%B9%B8%E5%AD%98%E8%80%85/ class=md-nav__link> 波黑围城战中的幸存者 </a> </li> <li class=md-nav__item> <a href=../%E6%AD%A6%E6%B1%89%EF%BC%9A%E7%99%BE%E5%B9%B4%E7%9A%84%E6%B4%AA%E6%B0%B4%E8%AE%B0%E5%BF%86/ class=md-nav__link> 武汉：百年的洪水记忆 </a> </li> <li class=md-nav__item> <a href=../../Python/python%E5%88%B6%E4%BD%9Cpdf%E7%94%B5%E5%AD%90%E4%B9%A6/ class=md-nav__link> Python制作pdf电子书 </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label=目录> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#_1 class=md-nav__link> 常用工具 </a> <nav class=md-nav aria-label=常用工具> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_2 class=md-nav__link> 分解大素数 </a> </li> <li class=md-nav__item> <a href=#sagehttpssagecellsagemathorg class=md-nav__link> 在线sage环境：https://sagecell.sagemath.org/ </a> </li> <li class=md-nav__item> <a href=#openssl class=md-nav__link> Openssl </a> </li> <li class=md-nav__item> <a href=#_3 class=md-nav__link> 脚本集 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_4 class=md-nav__link> 常见类型 </a> <nav class=md-nav aria-label=常见类型> <ul class=md-nav__list> <li class=md-nav__item> <a href=#pqec class=md-nav__link> 给p,q,e,c </a> </li> <li class=md-nav__item> <a href=#nedpc class=md-nav__link> 给n,e,dp,c </a> </li> <li class=md-nav__item> <a href=#pqdpdqc class=md-nav__link> 给p,q,dp,dq,c </a> </li> <li class=md-nav__item> <a href=#edwiener-attack class=md-nav__link> 低解密指数攻击/低私钥指数攻击（e长度较大，d小，Wiener Attack） </a> </li> <li class=md-nav__item> <a href=#hastad class=md-nav__link> 低加密指数广播攻击（Hastad攻击） </a> </li> <li class=md-nav__item> <a href=#nmce class=md-nav__link> 共模攻击（n,m相同，c,e不同） </a> </li> <li class=md-nav__item> <a href=#emnngcd class=md-nav__link> e,m相同，多个n中存在两个n有GCD（模不互素） </a> </li> <li class=md-nav__item> <a href=#rabin class=md-nav__link> Rabin加密 </a> </li> <li class=md-nav__item> <a href=#boneh-and-durfee-attack class=md-nav__link> Boneh and Durfee attack </a> </li> <li class=md-nav__item> <a href=#coppersmithp class=md-nav__link> Coppersmith攻击（已知p的高位攻击） </a> </li> <li class=md-nav__item> <a href=#coppersmithm class=md-nav__link> Coppersmith攻击（已知m的高位攻击） </a> </li> <li class=md-nav__item> <a href=#coppersmithd class=md-nav__link> Coppersmith攻击（已知d的低位攻击） </a> </li> <li class=md-nav__item> <a href=#coppersmithnp class=md-nav__link> Coppersmith攻击（已知N一个因子的高位，部分p） </a> </li> <li class=md-nav__item> <a href=#coppersmiths-short-pad-attack-related-message-attackfranklin-reiter class=md-nav__link> Coppersmith’s Short-pad Attack &amp; Related Message Attack（Franklin-Reiter攻击） </a> </li> <li class=md-nav__item> <a href=#rsa-hastad-attack-with-non-linear-padding-and-different-public-keyspadding class=md-nav__link> RSA Hastad Attack with non-linear padding and different public keys（带非线性padding和不同公钥的广播攻击） </a> </li> <li class=md-nav__item> <a href=#least-significant-bit-oracle-attack-lsb-oracle-attack-parity-oracle class=md-nav__link> Least Significant Bit Oracle Attack （LSB Oracle Attack / Parity Oracle） </a> </li> <li class=md-nav__item> <a href=#common-private-exponentd class=md-nav__link> Common Private Exponent（共私钥指数攻击，d相同） </a> </li> <li class=md-nav__item> <a href=#_5 class=md-nav__link> 多组低解密指数攻击 </a> </li> <li class=md-nav__item> <a href=#rsa class=md-nav__link> 多项式RSA </a> </li> <li class=md-nav__item> <a href=#weak-prime-factors-p class=md-nav__link> Weak prime factors （p具线性特征） </a> </li> <li class=md-nav__item> <a href=#_6 class=md-nav__link> 其他特别情形 </a> <nav class=md-nav aria-label=其他特别情形> <ul class=md-nav__list> <li class=md-nav__item> <a href=#multi-prime-rsa class=md-nav__link> 多素数因子（Multi-prime RSA） </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_7 class=md-nav__link> 详细原理 </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1>RSA</h1> <style>
.mjx-block {
    text-align: left;
    display: inline-block;
}

.mjx-chtml {
    display: inline-block;
    text-align: left;
    font-size: 80%;
    background-color: lightgrey;
}
</style> <script type=text/x-mathjax-config>
MathJax.Hub.Config({
    "HTML-CSS": { linebreaks: { automatic: true } },
         SVG: { linebreaks: { automatic: true } }
});
</script> <script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script> <h3 id=_1>常用工具</h3> <h5 id=_2>分解大素数</h5> <p><strong>factordb</strong> （<a href=http://www.factordb.com/ >http://www.factordb.com</a>）</p> <p><strong>yafu</strong>（p,q相差过大或过小yafu可分解成功）</p> <p><strong>sage</strong> （<code>divisors(n)</code>）（小素数）</p> <p><strong>Pollard’s p−1</strong> （<code>python -m primefac -vs -m=p-1 xxxxxxx</code>）（光滑数）</p> <p><strong>Williams’s p+1</strong>（<code>python -m primefac -vs -m=p+1 xxxxxxx</code>）（光滑数）</p> <h5 id=sagehttpssagecellsagemathorg>在线<strong>sage</strong>环境：<a href=https://sagecell.sagemath.org/ >https://sagecell.sagemath.org/</a></h5> <h5 id=openssl><strong>Openssl</strong></h5> <p>解析加密密钥：</p> <blockquote> <p>openssl rsa -pubin -text -modulus -in pub.key</p> </blockquote> <p>生成解密密钥：</p> <blockquote> <p>python rsatool.py -f PEM -o key.key -p 1 -q 1 -e 1</p> <p>openssl rsautl -decrypt -inkey key.pem -in flag.enc -out flag</p> <p>openssl rsautl -decrypt -oaep -inkey key.pem -in flag.enc -out flag （OAEP方式）</p> </blockquote> <p>脚本生成解密密钥：</p> <pre><code># coding=utf-8
import math
import sys
from Crypto.PublicKey import RSA

keypair = RSA.generate(1024)
keypair.p =
keypair.q =
keypair.e =
keypair.n = keypair.p * keypair.q
Qn = long((keypair.p - 1) * (keypair.q - 1))

i = 1
while (True):
    x = (Qn * i) + 1
    if (x % keypair.e == 0):
        keypair.d = x / keypair.e
        break
    i += 1
private = open('private.pem', 'w')
private.write(keypair.exportKey())
private.close()
</code></pre> <h5 id=_3><strong>脚本集</strong></h5> <pre><code>+ &lt;https://github.com/Ganapati/RsaCtfTool&gt;
</code></pre> <pre><code>#用法一：已知公钥(自动求私钥)
  $ python3 RsaCtfTool.py --publickey 公钥文件 --uncipherfile 加密文件

#用法二：已知公钥求私钥
  $ python3 RsaCtfTool.py --publickey 公钥文件 --private

#用法三：密钥格式转换
  #把PEM格式的公钥转换为n，e
  $ python3 RsaCtfTool.py --dumpkey --key 公钥文件
  #把n,e转换为PEM格式
  $ python3 RsaCtfTool.py --createpub -n 782837482376192871287312987398172312837182 -e 65537

</code></pre> <pre><code>+ &lt;https://github.com/yifeng-lee/RSA-In-CTF&gt;
+ &lt;https://github.com/ValarDragon/CTF-Crypto&gt;

​
</code></pre> <h3 id=_4>常见类型</h3> <h4 id=pqec>给p,q,e,c</h4> <pre><code>import gmpy2 as gp
import binascii
p =  
q =  
e =  
c =  
n = p*q
phi = (p-1)*(q-1)
d = gp.invert(e,phi)
m = pow(c,d,n)
print(m)
print(bytes.fromhex(hex(m)[2:]))
</code></pre> <p>​</p> <h4 id=nedpc>给n,e,dp,c</h4> <p>$$dp\equiv d \pmod {(p-1)}$$</p> <p>$$\because dp\cdot e\equiv d\cdot e\equiv 1 \pmod {(p-1)}$$</p> <p>$$\therefore dp\cdot e-1=k\cdot (p-1)$$</p> <p>$$\therefore (dp\cdot e-1)\cdot d\cdot e=k’\cdot (p-1),\quad k’=k\cdot d\cdot e \ \Leftrightarrow d\cdot e=-k’\cdot (p-1)+dp\cdot e\cdot d\cdot e\equiv 1 \pmod{\varphi(n)} \ \Leftrightarrow -k’\cdot (p-1)+dp\cdot e\equiv 1\pmod{\varphi(n)}$$</p> <p>$$\therefore k_{1}\cdot (p-1)+dp\cdot e-1=k_{2}\cdot (p-1)\cdot (q-1) \ \Leftrightarrow (p-1)\cdot (k_{2}\cdot (q-1)-k_{1})+1=dp\cdot e$$</p> <p>$$\because dp&lt;p-1\quad \therefore (k_{2}\cdot (q-1)-k_{1})\in (0, e)$$</p> <p>$$\therefore$$ 遍历 $$(1, e)$$，当同时满足 $$(dp\cdot e-1)\bmod i==0$$ 和 $$n\bmod((dp\cdot e-1)//i+1)==0$$ 时，$$N$$ 成功分解。</p> <pre><code>import gmpy2 as gp

e = 
n = 
dp = 
c = 

for x in range(1, e):
    if(e*dp%x==1):
        p=(e*dp-1)//x+1
        if(n%p!=0):
            continue
        q=n//p
        phin=(p-1)*(q-1)
        d=gp.invert(e, phin)
        m=gp.powmod(c, d, n)
        if(len(hex(m)[2:])%2==1):
            continue
        print('--------------')
        print(m)
        print(hex(m)[2:])
        print(bytes.fromhex(hex(m)[2:]))
</code></pre> <ul> <li><strong>变种1：</strong>给 $$p,e,d_p,c,b$$，其中 $$n=p^bq$$。</li> </ul> <p><a href="https://books.google.com.hk/books?
id=LAxAdqv1z7kC&printsec=frontcover#v=onepage&amp;q&f=false">Hensel lifting for Takagi’s scheme</a>（p.189）：</p> <p><img alt="Hensel_lifting_for_Takagi's_scheme" src="https://img.vjob.top/imgs/vjob_Hensel_lifting_for_Takagi's_scheme.jpg"></p> <pre><code>from Crypto.Util.number import *
import gmpy2
p = 
dp = 
c = 
b = 
e = 
mp1 = pow(c, dp, p)
mp = pow(c, dp - 1, p)
for i in range(1, b - 2):
    x = pow(c - pow(mp1, e), 1, p**(i + 1))
    y = pow(x * mp * (gmpy2.invert(e, p)), 1, p**(i + 1))
    mp1 = mp1 + y
print(long_to_bytes(mp1))

</code></pre> <ul> <li><strong>变种2</strong>：给 $$n,e,dp_0,c,k$$，其中 $$dp_0$$ 为 $$dp$$ 高 $$(n\text{bits}-k)$$ 位，即 $$dp_0=dp&gt;&gt;k$$。</li> </ul> <p>（Coppersmith攻击，已知dp高位攻击）</p> <p>$$e\cdot dp \equiv e\cdot d\equiv 1 \pmod {(p-1)} \ \Leftrightarrow e \cdot dp=k(p-1)+1=kp-k+1 \ \Leftrightarrow e\cdot dp+k-1 \equiv 0 \pmod p$$</p> <p>$$\because dp&lt;p-1$$，$$\therefore k&lt;e$$</p> <p>$$\therefore e\cdot (dp_0&lt;&lt;k+x)+k-1 \equiv 0 \pmod p$$</p> <pre><code>#Sage
dp0 = 
e = 
n = 

F.&lt;x&gt; = PolynomialRing(Zmod(n))
d = inverse_mod(e, n)
for k in range(1, e):
    f = (secret &lt;&lt; 200) + x + (k - 1) * d
    x0 = f.small_roots(X=2 ** (200 + 1), beta=0.44, epsilon=1/32)
    if len(x0) != 0:
        dp = x0[0] + (secret &lt;&lt; 200)
        for i in range(2, e):
            p = (e * Integer(dp) - 1 + i) // i
            if n % p == 0:
                break
        if p &lt; 0:
            continue
        else:
            print('k = ',k)
            print('p = ',p)
            print('dp = ',dp)
            break

</code></pre> <ul> <li><strong>变种3</strong>：给 $$n,e,dp,c$$​​，其中 $$dp$$​​​ 很小，$$e$$ 很大。</li> </ul> <p>枚举 $$dp$$，因 $$e\cdot dp \equiv 1 \pmod {(p-1)}$$，又由费马小定理，对任意 $$r$$，有 $$m^{e \cdot dp}\equiv m \pmod p$$，即 $$p \mid (m^{e \cdot dp}-m)$$；</p> <p>又 $$p \mid n$$，很大概率 $$p=\gcd(m^{e \cdot dp}-m,n)$$。</p> <p>​</p> <h4 id=pqdpdqc>给p,q,dp,dq,c</h4> <p>$$dp=d \bmod (p-1)$$，$$dq=d \bmod (q-1)$$</p> <p>$$\because d=k_{1}(p-1)+dp=k_{2}(q-1)+dq \ \Leftrightarrow k_{1}(p-1)=(dq-dp)+k_{2}(q-1) \ \Leftrightarrow k_{1}\frac{p-1}{\gcd(p-1,q-1)}=\frac{dq-dp}{\gcd(p-1,q-1)}+k_{2}\frac{q-1}{\gcd(p-1,q-1)} \ \Rightarrow k_{1}\frac{p-1}{\gcd(p-1,q-1)}\equiv\frac{dq-dp}{\gcd(p-1,q-1)} \pmod {\frac{q-1}{\gcd(p-1,q-1)}} \ \Leftrightarrow k_{1}\equiv \text{inv}(\frac{p-1}{\gcd(p-1,q-1)},\frac{q-1}{\gcd(p-1,q-1)})\cdot \frac{dq-dp}{\gcd(p-1,q-1)} \pmod {\frac{q-1}{\gcd(p-1,q-1)}}$$</p> <p>将 $$k_{1}=k_{3}\frac{q-1}{\gcd(p-1,q-1)}+\text{inv}(\frac{p-1}{\gcd(p-1,q-1)},\frac{q-1}{\gcd(p-1,q-1)})\cdot \frac{dq-dp}{\gcd(p-1,q-1)}$$</p> <p>代入 $$d=k_{1}(p-1)+dp$$</p> <p>$$d=k_{3}\frac{(p-1)(q-1)}{\gcd(p-1,q-1)}+\text{inv}(\frac{p-1}{\gcd(p-1,q-1)},\frac{q-1}{\gcd(p-1,q-1)})\cdot \frac{(dq-dp)(p-1)}{\gcd(p-1,q-1)}+dp \ \Rightarrow d\equiv \text{inv}(\frac{p-1}{\gcd(p-1,q-1)},\frac{q-1}{\gcd(p-1,q-1)})\cdot \frac{(dq-dp)(p-1)}{\gcd(p-1,q-1)}+dp \pmod{\frac{(p-1)(q-1)}{\gcd(p-1,q-1)}}$$</p> <pre><code>import gmpy2 as gp

p = 
q = 
dp = 
dq = 
c = 

n = p*q
phin = (p-1)*(q-1)
dd = gp.gcd(p-1, q-1)
d=(dp-dq)//dd * gp.invert((q-1)//dd, (p-1)//dd) * (q-1) +dq
print(d)

m = gp.powmod(c, d, n)
print('-------------------')
print(m)
print(hex(m)[2:])
print(bytes.fromhex(hex(m)[2:]))

</code></pre> <p>​</p> <h4 id=edwiener-attack>低解密指数攻击/低私钥指数攻击（e长度较大，d小，Wiener Attack）</h4> <p><strong>适用情况：已知 $$N,e$$，且 $$e$$ 过大或过小。</strong></p> <p>$$\varphi(n) = (p-1)(q-1)=pq - (p + q) + 1=N - (p + q) + 1$$</p> <p>$$\because p, q$$ 非常大，$$\therefore\,pq\gg p+q$$， $$\therefore\varphi(n)\approx N$$</p> <p>$$\because ed\equiv1\,mod\,\varphi(n)$$，$$\therefore ed-1=k\varphi(n)$$，这个式子两边同除 $$d\varphi(n)$$ 可得：</p> <p>$$\cfrac{e}{\varphi(n)}-\cfrac{k}{d}=\cfrac{1}{d\varphi(n)}$$</p> <p>$$\because \varphi(n)\approx N$$，$$\therefore \cfrac{e}{N}-\cfrac{k}{d}=\cfrac{1}{d\varphi(n)}$$，同样 $$d\varphi(n)$$ 是一个很大的数，所以 $$\cfrac{e}{N}$$ 略大于 $$\cfrac{k}{d}$$</p> <p>因为 $$e$$ 和 $$N$$ 是知道的，所以计算出 $$\cfrac{e}{N}$$ 后，比它略小的 $$\cfrac{k}{d}$$ ，可以通过计算 $$\cfrac{e}{N}$$ 的连分数展开，依次算出这个分数每一个渐进分数，由于 $$\cfrac{e}{N}$$ 略大于 $$\cfrac{k}{d}$$，Wiener 证明了，该攻击能精确的覆盖 $$\cfrac{k}{d}$$。</p> <p>在 $$e$$ 过大或过小的情况下，可使用算法从 $$e$$ 中快速推断出 $$d$$ 的值。可以解决 $$q&lt;p&lt;2q,d&lt;\cfrac{1}{3}N^{\frac{1}{4}}$$ 的问题。</p> <p>RSAWienerHacker工具：<a href=https://github.com/pablocelayes/rsa-wiener-attack>https://github.com/pablocelayes/rsa-wiener-attack</a></p> <pre><code>#脚本1（带工具）
#python2
import RSAwienerHacker
n =
e =
d =  RSAwienerHacker.hack_RSA(e,n)
if d:
    print(d)
import hashlib
flag = &quot;flag{&quot; + hashlib.md5(hex(d)).hexdigest() + &quot;}&quot;
print flag

</code></pre> <pre><code>#脚本2
#sage
def rational_to_contfrac(x,y):
    # Converts a rational x/y fraction into a list of partial quotients [a0, ..., an]
    a = x // y
    pquotients = [a]
    while a * y != x:
        x, y = y, x - a * y
        a = x // y
        pquotients.append(a)
    return pquotients

def convergents_from_contfrac(frac):
    # computes the list of convergents using the list of partial quotients
    convs = [];
    for i in range(len(frac)): convs.append(contfrac_to_rational(frac[0 : i]))
    return convs

def contfrac_to_rational (frac):
    # Converts a finite continued fraction [a0, ..., an] to an x/y rational.
    if len(frac) == 0: return (0,1)
    num = frac[-1]
    denom = 1
    for _ in range(-2, -len(frac) - 1, -1): num, denom = frac[_] * num + denom, num
    return (num, denom)

n = 
e = 
c = 

def egcd(a, b):
    if a == 0: return (b, 0, 1)
    g, x, y = egcd(b % a, a)
    return (g, y - (b // a) * x, x)

def mod_inv(a, m):
    g, x, _ = egcd(a, m)
    return (x + m) % m

def isqrt(n):
    x = n
    y = (x + 1) // 2
    while y &lt; x:
        x = y
        y = (x + n // x) // 2
    return x

def crack_rsa(e, n):
    frac = rational_to_contfrac(e, n)
    convergents = convergents_from_contfrac(frac)

    for (k, d) in convergents:
        if k != 0 and (e * d - 1) % k == 0:
            phi = (e * d - 1) // k
            s = n - phi + 1
            # check if x*x - s*x + n = 0 has integer roots
            D = s * s - 4 * n
            if D &gt;= 0:
                sq = isqrt(D)
                if sq * sq == D and (s + sq) % 2 == 0: return d

d = crack_rsa(e, n)
m = hex(pow(c, d, n))[2:]
print(bytes.fromhex(m))
</code></pre> <pre><code>#脚本3
from Crypto.Util.number import long_to_bytes
e = 
n = 
c = 

#将分数x/y展开为连分数的形式
def transform(x,y):
    arr=[]
    while y:
        arr+=[x//y]
        x,y=y,x%y
    return arr

#求解渐进分数
def sub_fraction(k):
    x=0
    y=1
    for i in k[::-1]:
        x,y=y,x+i*y
    return (y,x)
data=transform(e,n)

for x in range(1,len(data)+1):
    data1=data[:x]
    d = sub_fraction(data1)[1]
    m = pow(c,d,n)
    flag = long_to_bytes(m)
    if b'flag{' in flag:
        print(flag)
        break
</code></pre> <ul> <li><strong>变种1</strong>：$$\cfrac{N_1}{N_2}&lt;\cfrac{q_1}{q_2}&lt;1$$</li> </ul> <p>参考：<a href=https://blog.csdn.net/weixin_44110537/article/details/108560055>2020年羊城杯 - RRRRRRRSA</a></p> <p>Paper: <a href=https://eprint.iacr.org/2015/399.pdf>https://eprint.iacr.org/2015/399.pdf</a></p> <p>尝试对 $$\cfrac{N_1}{N_2}$$ 进行连分数展开并求其各项渐进分数，记为 $$\cfrac{t_i}{s_i}$$ 并验证 $$N_1\% {t_k}==0$$ 是否成立，如果成立，那么 $$q_1=t_k，q_2=s_k$$。</p> <p><strong>连分数逼近</strong>：</p> <pre><code>def transform(x,y):    #使用辗转相除将分数x/y转为连分数的形式
    res=[]
    while y:
        res.append(x//y)
        x,y=y,x%y
    return res

def continued_fraction(sub_res):
    numerator,denominator=1,0
    for i in sub_res[::-1]:   #从sublist的后面往前循环
        denominator,numerator=numerator,i*numerator+denominator
    return denominator,numerator   #得到渐进分数的分母和分子，并返回

#求解每个渐进分数
def sub_fraction(x,y):
    res=transform(x,y)
    res=list(map(continued_fraction,(res[0:i] for i in range(1,len(res)))))  #将连分数的结果逐一截取以求渐进分数
    return res

def wienerAttack(n1,n2):
    for (q2,q1) in sub_fraction(n1,n2):  #用一个for循环来注意试探n1/n2的连续函数的渐进分数，直到找到一个满足条件的渐进分数
        if q1==0:                    #可能会出现连分数的第一个为0的情况，排除
            continue
        if n1%q1==0 and q1!=1:           #成立条件
            return (q1,q2)
    print(&quot;该方法不适用&quot;)

N1=60143104944034567859993561862949071559877219267755259679749062284763163484947626697494729046430386559610613113754453726683312513915610558734802079868190554644983911078936369464590301246394586190666760362763580192139772729890492729488892169933099057105842090125200369295070365451134781912223048179092058016446222199742919885472867511334714233086339832790286482634562102936600597781342756061479024744312357407750731307860842457299116947352106025529309727703385914891200109853084742321655388368371397596144557614128458065859276522963419738435137978069417053712567764148183279165963454266011754149684758060746773409666706463583389316772088889398359242197165140562147489286818190852679930372669254697353483887004105934649944725189954685412228899457155711301864163839538810653626724347
N2=60143104944034567859993561862949071559877219267755259679749062284763163484947626697494729046430386559610613113754453726683312513915610558734802079868195633647431732875392121458684331843306730889424418620069322578265236351407591029338519809538995249896905137642342435659572917714183543305243715664380787797562011006398730320980994747939791561885622949912698246701769321430325902912003041678774440704056597862093530981040696872522868921139041247362592257285423948870944137019745161211585845927019259709501237550818918272189606436413992759328318871765171844153527424347985462767028135376552302463861324408178183842139330244906606776359050482977256728910278687996106152971028878653123533559760167711270265171441623056873903669918694259043580017081671349232051870716493557434517579121
print(wienerAttack(N1,N2))

</code></pre> <p>​</p> <h4 id=hastad>低加密指数广播攻击（Hastad攻击）</h4> <p><strong>适用情况： $$n,c$$ 不同，$$m,e$$ 相同。一般会是 $$e=k$$，然后给 $$k$$ 组数据。</strong></p> <p>如果一个用户使用同一个加密指数 e 加密了同一个密文，并发送给了其他 e 个用户。那么就会产生广播攻击。这一攻击由 Håstad 提出。</p> <p>使用不同的模数 $$n$$，相同的公钥指数 $$e$$ 加密相同的信息，就会得到多个 $$m^e \equiv c_i \pmod {n_i}$$，将 $$m^e$$ 视为一个整体 $$M$$，这就是典型的<strong>中国剩余定理</strong>适用情况。容易求得 $$m^e$$ 的值，当 $$e$$ 较小时直接开 $$e$$ 方即可，可使用<code>gmpy2.iroot(M,e)</code> 方法。</p> <p>更一般情况（$$k$$ 组数据的 $$N$$ 不同）见15。</p> <pre><code>#sage
def chinese_remainder(modulus, remainders):
 Sum = 0
    prod = reduce(lambda a, b: a*b, modulus)
 for m_i, r_i in zip(modulus, remainders):
        p = prod // m_i
     Sum += r_i * (inverse_mod(p,m_i)*p)
    return Sum % prod
chinese_remainder([3,5,7],[2,3,2]) #23
</code></pre> <pre><code>#sage
crt([2,3,2],[3,5,7])
</code></pre> <p>​</p> <h4 id=nmce>共模攻击（n,m相同，c,e不同）</h4> <p>当$$n$$不变的情况下，知道$$n,e_1,e_2,c_1,c_2$$可以在不知道$$d_1,d_2$$的情况下，解出$$m$$。</p> <p>首先假设$$e_1,e_2$$互质,</p> <p>即 $$\gcd(e_1,e_2)=1$$</p> <p>此时则有 $$e_1s_1+e_2s_2 = 1$$</p> <p>式中，$$s_1,s_2$$皆为整数，但是一正一负。</p> <p>通过扩展欧几里德算法，我们可以得到该式子的一组解$$（s_1,s_2）$$，假设$$s_1$$为正数,$$s_2$$为负数。</p> <p>因为 $$c_1 = m^{e_1}\bmod n, c_2 = m^{e_2}\bmod n$$</p> <p>所以 $$(c_1^{s_1}c_2^{s_2})\bmod n = ((m^{e_1}\bmod n)^{s_1}(m^{e_2}\bmod n)^{s_2})\bmod n$$</p> <p>根据模运算性质，可以化简为 $$(c_1^{s_1}c_2^{s_2})\bmod n = ((m^{e_1})^{s_1}(m^{e_2})^{s_2})\bmod n$$</p> <p>即 $$(c_1^{s_1}c_2^{s_2})\bmod n = (m^{e_1s_1+e_2s_2})\bmod n$$</p> <p>又前面提到 $$e_1s_1+e_2s_2 = 1$$</p> <p>所以 $$(c_1^{s_1}c_2^{s_2})\bmod n = m\bmod n$$</p> <p>即 $$c_1^{s_1}c_2^{s_2}= m$$</p> <pre><code>import gmpy2 as gp
def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

n = 
c1 = 
c2 = 
e1 = 
e2 = 
s = egcd(e1, e2)
s1 = s[1]
s2 = s[2]
if s1&lt;0:
    s1 = - s1
    c1 = gp.invert(c1, n)
elif s2&lt;0:
    s2 = - s2
    c2 = gp.invert(c2, n)

m = pow(c1,s1,n)*pow(c2,s2,n) % n
print(hex(m)[2:])
print(bytes.fromhex(hex(m)[2:]))
</code></pre> <p>​</p> <h4 id=emnngcd>e,m相同，多个n中存在两个n有GCD（模不互素）</h4> <p><strong>适用情况：存在两个或更多模数 ，且 $$\gcd(n_1,n_2)\ne 1$$ 。</strong></p> <p>多个模数 $$n$$ 共用质数，则可以很容易利用欧几里得算法求得他们的质因数之一 $$\gcd(n_1,n_2)$$，然后这个最大公约数可用于分解模数分别得到对应的 $$p$$ 和 $$q$$，即可进行解密。</p> <pre><code>import gmpy2 as gp

n=[]
for i in n:
    for j in n:
        if (i&lt;&gt;j):
            pub_p=gp.gcdext(i,j)
            if (pub_p[0]&lt;&gt;1)&amp;(i&gt;j):
                print(i)
                print(j)
                print(pub_p[0])
                a=i,p=pub_p[0]
q=a//p
p =
q =
e =
c =
n = p*q
phi = (p-1) * (q-1)
d = gp.invert(e, phi)
m = pow(c, d, n)
print(hex(m)[2:])
print(bytes.fromhex(hex(m)[2:]))
</code></pre> <p>​</p> <h4 id=rabin>Rabin加密</h4> <p><strong>适用情况：$$e=2$$ 。</strong></p> <p>一般先通过其他方法分解得到 $$p,q$$，然后解密。</p> <p>函数返回四个数，这其中只有一个是我们想要的明文，需要通过其他方式验证。</p> <pre><code>import gmpy2

def rabin_decrypt(c, p, q, e=2):
    n = p * q
    mp = pow(c, (p + 1) // 4, p)
    mq = pow(c, (q + 1) // 4, q)
    yp = gmpy2.invert(p, q)
    yq = gmpy2.invert(q, p)
    r = (yp * p * mq + yq * q * mp) % n
    rr = n - r
    s = (yp * p * mq - yq * q * mp) % n
    ss = n - s
    return (r, rr, s, ss)

c = 
p = 
q = 
m = rabin_decrypt(c,p,q)
for i in range(4):
    try:
        print(bytes.fromhex(hex(m[i])[2:]))
    except:
        pass
</code></pre> <p>​</p> <h4 id=boneh-and-durfee-attack>Boneh and Durfee attack</h4> <p>$$e$$ 非常大接近于$$N$$，即 $$d$$ 较小时。与低解密指数攻击类似，比低解密指数攻击（Wiener Attack）更强，可以解决$$\cfrac{1}{3}N^{\frac{1}{4}} \leq d \leq N^{0.292}$$的问题。</p> <p>参考 <a href=https://github.com/mimoo/RSA-and-LLL-attacks>https://github.com/mimoo/RSA-and-LLL-attacks</a> 。</p> <pre><code>2k [(N + 1)/2 + (-p -q)/2] + 1 = 0 mod e

Boneh and Durfee attack:
f(x,y) = 1 + x * (A + y)
e d = x [(N + 1)/2 + y] + 1
故：
x = 2k
y = (-p-q)/2

</code></pre> <ul> <li><strong>变种1</strong>：$$e$$ 很大，$$dp$$ 很小，且 $$d&gt;2N^{\beta}$$。</li> </ul> <p><strong>May’s Attack</strong></p> <p>假设 $$e&lt;\varphi(N),q \le N^{\beta},\beta \le \frac{1}{2}$$，因 $$ed_p \equiv 1 \pmod {p-1}$$，有 $$ed_p=1+k(p-1)$$，</p> <p>对于 $$k \in \mathbb{N}$$，有 $$ed_p=(k-1)(p-1)+p$$，即 $$ed_pq=(k-1)(N-q)+N$$。</p> <p>设 $$x,y$$ 为参数，则多项式 $$f(x,y)=x(N-y)+N$$ 在模 $$e$$ 下存在根 $$(x_0,y_0)=(k-1,q)$$，用coppersmith attack可解。</p> <p>​</p> <blockquote> <p>Coppersmith定理指出在一个 $$e$$ 阶的 $$\bmod n$$ 多项式 $$f(x)$$ 中，如果有一个根小于 $$n^{\frac{1}{e}}$$，就可以运用一个 $$O(\log n)$$ 的算法求出这些根。</p> </blockquote> <h4 id=coppersmithp>Coppersmith攻击（已知p的高位攻击）</h4> <p>知道 $$p$$ 的高位为 $$p$$ 的位数的约$$\frac12$$时即可。</p> <pre><code>#Sage
from sage.all import *
n = 
p4 = 
#p去0的剩余位
e =  
pbits = 1024
kbits = pbits - p4.nbits()
print(p4.nbits())
p4 = p4 &lt;&lt; kbits
PR.&lt;x&gt; = PolynomialRing(Zmod(n))
f = x + p4
roots = f.small_roots(X=2^kbits, beta=0.4)
#经过以上一些函数处理后，n和p已经被转化为10进制
if roots:        
    p = p4+int(roots[0]) 
    print(&quot;n: &quot;+str(n))
    print(&quot;p: &quot;+str(p))
    print(&quot;q: &quot;+str(n//p))
</code></pre> <p>​</p> <h4 id=coppersmithm>Coppersmith攻击（已知m的高位攻击）</h4> <p>这里我们假设我们首先加密了消息 $$m$$，如下</p> <p>$$C\equiv m^e \bmod N$$</p> <p>并且我们假设我们知道消息 $$m$$ 的很大的一部分 $$m_0$$，即 $$m=m_0+x$$，但是我们不知道 $$x$$。那么我们就有可能通过该方法进行恢复消息。这里我们不知道的 $$x$$ 其实就是多项式的根，需要满足 Coppersmith 的约束。</p> <p>可以参考 <a href=https://github.com/mimoo/RSA-and-LLL-attacks>https://github.com/mimoo/RSA-and-LLL-attacks</a> 。</p> <p>$$e$$ 足够小，且部分明文泄露时，可以采用Coppersmith单变量模等式的攻击，如下：</p> <p>$$c=m^{e}\bmod n=(mbar+x_{0})^{e}\bmod n$$，其中 $$mbar = (m &gt;&gt; k\text{bits}) &lt;&lt; k\text{bits}$$</p> <p>当 $$\vert x_{0}\vert\leq N^{\frac{1}{e}}$$ 时，可以在 $$\log N$$ 和 $$e$$ 的多项式时间内求出 $$x_0$$。</p> <pre><code>#Sage
n = 
e = 
c = 
mbar = 
kbits = 
beta = 1
nbits = n.nbits()
print(&quot;upper {} bits of {} bits is given&quot;.format(nbits - kbits, nbits))
PR.&lt;x&gt; = PolynomialRing(Zmod(n))
f = (mbar + x)^e - c
x0 = f.small_roots(X=2^kbits, beta=1)[0]  # find root &lt; 2^kbits with factor = n
print(&quot;m:&quot;, mbar + x0)
</code></pre> <p>​</p> <h4 id=coppersmithd>Coppersmith攻击（已知d的低位攻击）</h4> <p>如果知道 $$d$$ 的低位，低位约为 $$n$$ 的位数的 $$\frac14$$ （$$\frac{n.n\text{bits}()}{4}$$）就可以恢复 $$d$$。</p> <pre><code>#Sage
def partial_p(p0, kbits, n):
    PR.&lt;x&gt; = PolynomialRing(Zmod(n))
    nbits = n.nbits()
    f = 2^kbits*x + p0
    f = f.monic()
    roots = f.small_roots(X=2^(nbits//2-kbits), beta=0.4)  # find root &lt; 2^(nbits//2-kbits) with factor &gt;= n^0.4
    if roots:
        x0 = roots[0]
        p = gcd(2^kbits*x0 + p0, n)
        return ZZ(p)
def find_p(d0, kbits, e, n):
    X = var('X')
    for k in range(1, e+1):
        results = solve_mod([e*d0*X - k*X*(n-X+1) + k*n == X], 2^kbits)
        for x in results:
            p0 = ZZ(x[0])
            p = partial_p(p0, kbits, n)
            if p and p != 1:
                return p
if __name__ == '__main__':
    n = 
    e = 
    c = 
    d0 = 
    beta = 0.5
    nbits = n.nbits()
    kbits = d0.nbits()
    print(&quot;lower %d bits (of %d bits) is given&quot; % (kbits, nbits))
    p = int(find_p(d0, kbits, e, n))
    print(&quot;found p: %d&quot; % p)
    q = n//int(p)
    print(&quot;d:&quot;, inverse_mod(e, (p-1)*(q-1)))
</code></pre> <ul> <li><strong>变种1</strong>：$$n=p\cdot q\cdot r$$，已知 $$n,p,d=\text{inv}(e,\varphi(n)),e,c$$</li> </ul> <p>$$k(p-1)\rightarrow k’,qr\rightarrow n’,q+r\rightarrow s$$</p> <p>$$ed_{0}\equiv 1+k’(n’-s+1) \pmod {2^{d_{0}.n\text{bits}()}}\quad (1)$$</p> <p>$$q^{2}-sq+n’\equiv 0 \pmod {2^{d_{0}.n\text{bits}()}}\quad (2)$$</p> <p>联立可得，$$(ed_{0}-1-k’n’-k’)q+k’q^{2}+k’n’\equiv 0 \pmod {2^{d_{0}.n\text{bits}()}}$$</p> <p>即求解同余方程可得 $$q$$ 的低 $$size(d0)$$ 位，本来是个partial d的coppersmith问题，但因为step1求解同余方程后得到的 $$q$$ 已是完整的 $$q$$，所以无需后续的coppersmith。</p> <p>参考：<a href=https://www.anquanke.com/post/id/188838>Dragon CTF 2019 - RSA Chained</a></p> <pre><code>#Sage
def find_p(d0, kbits, e, n, p):
    X = var('X')
    for k in range(1, e + 1):
        k_dot = k * (p - 1)
        results = solve_mod([e * d0 * X - k_dot * X * (n - X + 1) + k_dot * n == X], 2^kbits)
        for x in results:
            q = ZZ(x[0])
            if n % q == 0:
                return q
    return None

n = ... # q * r
p = 
c = 
d0 = 
e = 
kbits = d0.nbits()
q = find_p(d0, kbits, e, n, p)
phi = (p - 1) * (q - 1) * (n // q - 1)
d = inverse_mod(e, phi)
print(bytes.fromhex(hex(pow(c, d, p * n))[2:]))
</code></pre> <p>​</p> <h4 id=coppersmithnp>Coppersmith攻击（已知N一个因子的高位，部分p）</h4> <p>当我们知道一个公钥中模数 $$N$$ 的一个因子的较高位时，我们就有一定几率来分解 $$N$$。</p> <p>参考 <a href=https://github.com/mimoo/RSA-and-LLL-attacks>https://github.com/mimoo/RSA-and-LLL-attacks</a> 。</p> <p>关注下面的代码：</p> <pre><code>beta = 0.5
dd = f.degree()
epsilon = beta / 7
mm = ceil(beta**2 / (dd * epsilon))
tt = floor(dd * mm * ((1/beta) - 1))
XX = ceil(N**((beta**2/dd) - epsilon)) + 1000000000000000000000000000000000
roots = coppersmith_howgrave_univariate(f, N, beta, mm, tt, XX)
</code></pre> <p>其中，</p> <ul> <li>必须满足 $$q\ge N^{beta}$$，所以这里给出了 $$beta=0.5$$，显然两个因数中必然有一个是大于的。</li> <li>XX 是 $$f(x)=q′+x$$ 在模 $$q$$ 意义下的根的上界，自然我们可以选择调整它，这里其实也表明了我们已知的 $$q′$$ 与因数 $$q$$ 之间可能的差距。</li> </ul> <pre><code>#Sage
n = 
e = 
c = 
pbar = 
kbits = 
print(&quot;upper %d bits (of %d bits) is given&quot; % (pbar.nbits()-kbits, pbar.nbits()))
PR.&lt;x&gt; = PolynomialRing(Zmod(n))
f = x + pbar
x0 = f.small_roots(X=2^kbits, beta=0.4)[0]  # find root &lt; 2^kbits with factor &gt;= n^0.4
p = x0 + pbar
print(&quot;p:&quot;, p)
q = n // int(p)
d = inverse_mod(e, (p-1)*(q-1))
print(&quot;m:&quot;, pow(c, d, n))
</code></pre> <p>注：</p> <p>sage的small_root传参<code>X</code>不能过大，需自行判断阈值并调整（如果X过大，即使存在X内的解，也无法求出）；</p> <p>比如 $$p$$ 的低位泄露时因为不确定缺失高位的具体比特数，所以要在 $$2^{\frac{n.n\text{bits}()}{2}−k\text{bits}}$$ 附近作X的阈值估计；</p> <p>无法确定拿到的 $$p$$ 是否大于 $$q$$，所以对 $$\beta=0.5$$ 进行调整至 $$0.4$$。</p> <p>​</p> <h4 id=coppersmiths-short-pad-attack-related-message-attackfranklin-reiter>Coppersmith’s Short-pad Attack &amp; Related Message Attack（Franklin-Reiter攻击）</h4> <p>目前在大部分消息加密之前都会进行 padding，但是如果 padding 的长度过短（$$m \in (0,\lfloor\frac{n.n\text{bits}()}{e^2}\rfloor]$$），也有<strong>可能</strong>被很容易地攻击。</p> <p>这里所谓 padding 过短，其实就是对应的多项式的根会过小。</p> <p>当 Alice 使用同一公钥对两个具有某种线性关系的消息 $$M_1$$ 与 $$M_2$$ 进行加密，并将加密后的消息 $$C_1$$，$$C_2$$ 发送给了 Bob 时，我们就可能可以获得对应的消息 $$M_1$$ 与 $$M_2$$ 。这里我们假设模数为 $$N$$，两者之间的线性关系如下：</p> <p>$$M_1 \equiv f(M_2) \bmod N$$</p> <p>其中 $$f$$ 为一个线性函数，比如说 $$f=ax+b$$。</p> <p>在具有较小错误概率下的情况下，其复杂度为 $$O(e\log^2N)$$。</p> <p>这一攻击由 Franklin与Reiter 提出。</p> <pre><code>#脚本1
#Sage
import binascii
def attack(c1, c2, n, e):
    PR.&lt;x&gt;=PolynomialRing(Zmod(n))
    # replace a,b,c,d
    g1 = (a*x+b)^e - c1
    g2 = (c*x+d)^e - c2

    def gcd(g1, g2):
        while g2:
            g1, g2 = g2, g1 % g2
        return g1.monic()
    return -gcd(g1, g2)[0]
c1 =
c2 =
n =
e =
m1 = attack(c1, c2, n, e)
print(binascii.unhexlify(&quot;%x&quot; % int(m1)))
</code></pre> <pre><code>#脚本2
#Sage
def short_pad_attack(c1, c2, e, n):
    PRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n))
    PRx.&lt;xn&gt; = PolynomialRing(Zmod(n))
    PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n))
    g1 = x^e - c1
    g2 = (x+y)^e - c2
    q1 = g1.change_ring(PRZZ)
    q2 = g2.change_ring(PRZZ)
    h = q2.resultant(q1)
    h = h.univariate_polynomial()
    h = h.change_ring(PRx).subs(y=xn)
    h = h.monic()
    kbits = n.nbits()//(2*e*e)
    diff = h.small_roots(X=2^kbits, beta=0.4)[0]  # find root &lt; 2^kbits with factor &gt;= n^0.4
    return diff
def related_message_attack(c1, c2, diff, e, n):
    PRx.&lt;x&gt; = PolynomialRing(Zmod(n))
    g1 = x^e - c1
    g2 = (x+diff)^e - c2
    def gcd(g1, g2):
        while g2:
            g1, g2 = g2, g1 % g2
        return g1.monic()
    return -gcd(g1, g2)[0]
if __name__ == '__main__':
    n = 
    e = 
    c1 =
    c2 = 
    diff = short_pad_attack(c1, c2, e, n)
    print(&quot;difference of two messages is %d&quot; % diff)
    m1 = related_message_attack(c1, c2, diff, e, n)
    print(&quot;m1:&quot;, m1)
    print(&quot;m2:&quot;, m1 + diff)
</code></pre> <p>​</p> <h4 id=rsa-hastad-attack-with-non-linear-padding-and-different-public-keyspadding>RSA Hastad Attack with non-linear padding and different public keys（带非线性padding和不同公钥的广播攻击）</h4> <p><strong>适用情况：$$m$$ 经 $$k$$ 次非线性padding处理后，分别用 $$k$$ 组 $$(N_i,e_i)$$ 加密后得 $$k$$ 组 $$c_i$$。</strong></p> <p>参考：2020年羊城杯 - Invitation</p> <pre><code>#Sage
#e=3, padding: m²+(3^431)k
def linearPaddingHastads(cArray,nArray,aArray,bArray,eArray,eps):
    if(len(cArray) == len(nArray) == len(aArray) == len(bArray) == len(eArray)):
        for i in range(4):
            cArray[i] = Integer(cArray[i])
            nArray[i] = Integer(nArray[i])
            aArray[i] = Integer(aArray[i])
            bArray[i] = Integer(bArray[i])
            eArray[i] = Integer(eArray[i])
        TArray = [-1]*4
        for i in range(4):
            arrayToCRT = [0]*4
            arrayToCRT[i] = 1
            TArray[i] = crt(arrayToCRT,nArray)
        P.&lt;x&gt; = PolynomialRing(Zmod(prod(nArray)))
        gArray = [-1]*4
        for i in range(4):
            gArray[i] = TArray[i]*(pow(aArray[i]*x**2 + bArray[i],eArray[i]) - cArray[i])
        g = sum(gArray)
        g = g.monic()
        roots = g.small_roots(epsilon=eps)
        if(len(roots)== 0):
            print(&quot;No Solutions found!&quot;)
            return -1
        return roots
    else:
        print(&quot;Input error!&quot;)

def nonLinearPadding():
    eArr = [3 for i in range(4)]
    nArr = [146694460234280339612721415368435987068740712812770728817136582256341063038147863645902264969297892447333024201649306207442798919845916187823646745721109151386096190207317810424580842120750075213595282979568495342617919336417068886973047979116994072272482630372638964064972815256237040541007947708358680368391,65031485534704406281490718325237831433086480239135617407356760819741796565231283220528137697949585150709734732370203390254643835828984376427852793969716489016520923272675090536677771074867975287284694860155903327351119710765174437247599498342292671117884858621418276613385329637307269711179183430246951756029,126172075578367446151297289668746433680600889845504078949758568698284471307000358407453139846282095477016675769468273204536898117467559575203458221600341760844973676129445394999861380625435418853474246813202182316736885441120197888145039130477114127079444939102267586634051045795627433724810346460217871661901,75691424835079457343374072990750986689075078863640186724151061449621926239051140991748483370587430224317778303489124525034113533087612981452189061743589227565099659070008017454957304620495920813121234552401715857719372861565651204968408267740732475458128601061676264465241188491988485848198323410127587280471]
    cArr = [129274519334082165644106292383763271862424981496822335330342328217347928093592453953990448827969549377883054831490973006383371688359344675312001881631556371220779971357039899721241880304156884612458373310254854821837978876725801047977081900824202659636258168216028784656056334358157381820784576207338479493823,8140023566779187828652447593867705813386781164538611122714708931585587727699213769519135028841126072130625547328311301696554048174772606261707345115571968105138543476580875347239912760797035694220505996377127309341770427102697008350472060971360460756799310951343070384766137332401117333917901167639276168214,25434511525127530194830986592289179576070740435049947678930286998924519588985583799757299734846614343604661534391991096353170465467791358514448923161460366596251448937540153262731348684727026598527904328268639060306102090278287818149679940661579357649191023269947102746200467430583428889484549034314463114080,9435583236354598287661880148272717764447540972316605192855157484524753847806158586224733743434644389385148450722945845355791145016665856388503878165725148745517696840251674049929524448078129458846254866804153080766917319923905682824180976106679633180818527967145571143203594244851742143986040226240019541346]
    aArr = [1 for i in range(4)]
    bArr = [i * 3 ** 431 for i in [3,8,10,11]]
    msg = linearPaddingHastads(cArr,nArr,aArr,bArr,eArr,eps=1/20)
    for i in msg:
        print(bytes.fromhex(hex(i)[2:]))

if __name__ == '__main__':
    nonLinearPadding()

</code></pre> <p>​</p> <h4 id=least-significant-bit-oracle-attack-lsb-oracle-attack-parity-oracle>Least Significant Bit Oracle Attack （LSB Oracle Attack / Parity Oracle）</h4> <p><strong>适用情况：可以选择密文并泄露明文的最低位（奇偶性）。</strong></p> <p>假设存在一个oracle，能对给定密文进行解密并给出对应明文的奇偶信息，则我们只需要 $$\log(N)$$ 次就能解密任意密文。</p> <p>在一次RSA加密中，明文为 $$m$$，模数为 $$n$$，加密指数为 $$e$$，密文为 $$c$$。我们可以构造出</p> <p>$$c’=((2^e)\cdot c)\%n=((2^e)\cdot(m^e))\%n=((2\cdot m)^e)\%n$$ ，</p> <p>因为 $$m$$ 的两倍可能大于 $$n$$，所以经过解密得到的明文是 $$m’=(2\cdot m)\%n$$ 。</p> <p>我们还能够知道 $$m’$$ 的最低位<code>lsb</code> 是1还是0。 因为 $$n$$ 是奇数，而 $$2\cdot m$$ 是偶数，所以如果<code>lsb</code> 是0，说明$$(2\cdot m)\%n$$ 是偶数，没有超过 $$n$$，即 $$m\lt \cfrac{n}{2}$$ ，反之则 $$m\gt \cfrac{n}{2}$$ 。举个例子就能明白 $$2\%3=2$$ 是偶数，而$$4\%3=1$$ 是奇数。以此类推，构造密文 $$c’’=((4^e)\cdot c)\%n$$ 使其解密后为 $$m’’=(4\cdot m)\%n$$ ，判断 的奇偶性可以知道 $$m’’$$ 和 $$\cfrac{n}{4}$$ 的大小关系。所以我们就有了一个二分算法，可以在对数时间内将 $$m$$ 的范围逼近到一个足够狭窄的空间。</p> <p>更多信息可参考：<a href=https://introspelliam.github.io/2018/03/27/crypto/RSA-Least-Significant-Bit-Oracle-Attack/ >RSA Least-Significant-Bit Oracle Attack</a> 和 <a href=https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack>RSA least significant bit oracle attack</a> 。</p> <pre><code>import decimal
def oracle():
    return lsb == 'odd'

def partial(c, e, n):
    k = n.bit_length()
    decimal.getcontext().prec = k  # for 'precise enough' floats
    lo = decimal.Decimal(0)
    hi = decimal.Decimal(n)
    for i in range(k):
        if not oracle(c):
            hi = (lo + hi) / 2
        else:
            lo = (lo + hi) / 2
        c = (c * pow(2, e, n)) % n
        # print i, int(hi - lo)
    return int(hi)
</code></pre> <p>​</p> <h4 id=common-private-exponentd>Common Private Exponent（共私钥指数攻击，d相同）</h4> <p>加密用同样的私钥并且私钥比较短，从而导致了加密系统被破解。</p> <p>假定：</p> <p>$$\begin{cases} e_1d=1+k_1\varphi(N_1) \newline e_2d=1+k_2\varphi(N_2) \newline {\vdots} \newline e_rd=1+k_r\varphi(N_r) \end{cases}$$</p> <p>其中，$$N_1 \lt N_2 \lt \cdots \lt N_r \lt 2N_1$$。</p> <p>构造格：</p> <p>$$B_r=\begin{bmatrix}{M}&amp;{e_1}&amp;{e_2}&amp;{\cdots}&amp;{e_{r}}\newline<br> {0}&amp;{-N_1}&amp;{0}&amp;{\cdots}&amp;{0}\newline{0}&amp;{0}&amp;{-N_2}&amp;{\cdots}&amp;{0}\newline{\vdots}&amp;{\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\newline{0}&amp;{0}&amp;{0}&amp;{\cdots}&amp;{-N_r}\newline\end{bmatrix}$$</p> <p>其中 $$M=\lfloor N_r^{\frac{1}{2}} \rfloor$$。</p> <p>再利用<strong>LLL算法</strong>进行规约得到 $$\vert b_1\vert=Md$$，则 $$d=\cfrac{\vert b_1 \vert}{M}$$，从而解密密文得到明文。</p> <ul> <li>使用条件：</li> </ul> <p>$$d \lt N_r^{\delta_r}，\delta_r \lt \cfrac{1}{2}-\cfrac{1}{2(r+1)}-\log_{N_r}{(6)}$$ * 参考：</p> <p><a href=https://www.ijcsi.org/papers/IJCSI-9-2-1-311-314.pdf>Lattice Based Attack on Common Private Exponent RSA</a></p> <p>SCTF 2020 - RSA</p> <pre><code>###Sage###
from gmpy2 import *
e0=
n0=
c0=
e1=
n1=
c1=
e2=
n2=
c2=

M=iroot(int(n2),int(2))[0]
a=[0]*4
a[0]=[M,e0,e1,e2]
a[1]=[0,-n0,0,0]
a[2]=[0,0,-n1,0]
a[3]=[0,0,0,-n2]

Mat = matrix(ZZ,a)
Mat_LLL=Mat.LLL()
d = abs(Mat_LLL[0][0])/M
print(bytes.fromhex(hex(pow(c1,int(d),int(n1)))[2:]))
</code></pre> <p>​</p> <h4 id=_5>多组低解密指数攻击</h4> <p><strong>适用情况：2-4组 $$e$$，且 $$d$$ 较小</strong></p> <ul> <li><strong>给定2组</strong></li> </ul> <p>$$g=\gcd(p-1,q-1),\lambda(n)=\frac{\varphi(n)}{g},s=1-p-q$$</p> <p>且有 $$ed-k\lambda(n)=1$$，得到 $$edg-kn=g+ks\quad (1)$$</p> <p>设 $$e_1$$ 对应 $$k_1$$，$$e_2$$ 对应 $$k_2$$，则有 $$k_{2}d_{1}e{1}-k_{1}d_{2}e_{2}=k_{2}-k_{1}\quad (2)$$</p> <p>由(1)(2)有：</p> <p>$\left\{ \begin{matrix} e_{1}d_{1}g-k_{1}n=g+k_{1}s \newline k_{2}d_{1}e{1}-k_{1}d_{2}e_{2}=k_{2}-k_{1} \newline e_{1}e_{2}d_{1}d_{2}g_{2}-e_{1}d_{1}gk_{2}n-e_{2}d_{2}gk_{1}n+k_{1}k_{2}n^{2}=(g+k_{1}s)(g+k_{2}s) \end{matrix} \right.$</p> <p>上述等式组也可表示为</p> <p>$$bL_2 =[k_{1}k_{2},k_{2}d_{1}g,k_{1}d_{2}g,d_{1}d_{2}g^{2}]\cdot\left[ \begin{matrix} n &amp; -M_{1}n &amp; 0 &amp; n^{2} \newline 0 &amp; M_{1}e_{1} &amp; M_{2}e_{1} &amp; -e_{1}n \newline 0 &amp; 0 &amp; -M_{2}e_{2} &amp; -e_{2}n \newline 0 &amp; 0 &amp; 0 &amp; e_{1}e_{2} \end{matrix} \right] =[k_{1}k_{2}n,M_{1}k_{2}(g+k_{1}s),M_{2}g(k_{2}-k_{1})，(g+k_{1}s)(g+k_{2}s)]$$</p> <p>（其中 $$M_{1}=n^{1/2},M_{2}=n^{1+\alpha_{2}},d\approx n^{\alpha_{2}}$$）</p> <p>对部分参数进行上界估计，k上界近似于 $$d\approx N^{\alpha_{2}}$$, $$|s|$$ 上界 $$\approx N^{1/2}$$，$$g$$ 一般相对极小</p> <p>因此上面的矩阵表示 $$BA=C$$ 中，$$C$$ 的每个元的size都近似 $$n^{1+2\alpha_{2}}$$，所以 $$|C|\approx 2\cdot n^{1+2\alpha_{2}}$$</p> <p>$$B$$ 作为格基的格中，最短向量由Minkowski Bounds知 $$\approx \sqrt{4}\det(B)^{1/4}\approx 2\cdot n^{(13/2+\alpha_{2})/4}$$</p> <p>因此只要满足 $$n^{1+2\alpha_{2}}&lt;n^{(13/2+\alpha_{2})/4}$$ 即可将问题转化为SVP（$$\alpha_{2}&lt;\frac{5}{14}$$）</p> <pre><code>from sage.all import *
import gmpy2
N = 
e1 = 
e2 = 
c = 
 for i in range(1000):
    alpha2 = i/1000
     M1 = int(gmpy2.mpz(N)**0.5)
    M2 = int( gmpy2.mpz(N)**(1+alpha2) )
    D = diagonal_matrix(ZZ, [N, M1, M2, 1])
    B = Matrix(ZZ, [ [1, -N,   0,  N**2],
                 [0, e1, -e1, -e1*N],
                 [0,  0,  e2, -e2*N],
                 [0,  0,   0, e1*e2] ]) * D
    L = B.LLL()
    v = Matrix(ZZ, L[0])
    x = v * B**(-1)
    phi = (x[0,1]/x[0,0]*e1).floor()
    try:
        d = inverse_mod( 65537, phi)
        m = hex(power_mod(c, d, N))[2:]
        if m.startswith('44415343'):
            print(i)
            print(bytes.fromhex(m))
            break
    except:
        pass

</code></pre> <p>参考：<a href=https://0xdktb.top/2020/05/04/WriteUp-De1CTF2020-Crypto/ >De1CTF 2020 - easyRSA</a></p> <ul> <li><strong>给定3组</strong></li> </ul> <p>类似2组情况，其中</p> <p>$$b=[k_1k_2k_3,d_1gk_2k_3,k_1d_2gk_3,d_1d_2g^2k_3,k_1k_2d_3g,k_1d_3g,k_2d_3g,d_1d_2d_3g^3]$$</p> <p>$$L_3=\left[\begin{matrix} 1-N &amp; 0 &amp; N^2 &amp; 0 &amp; 0 &amp; 0 &amp; -N^3 \newline e_1 &amp; -e_1 &amp; -e_1N &amp; -e &amp; 0 &amp; e_1N &amp; e_1N^2 \newline 0 &amp; e_2 &amp; -e_2N &amp; 0 &amp; e_2N &amp; 0 &amp; e_2N^2 \newline 0 &amp; 0 &amp; e_1e_2 &amp; 0 &amp; -e_1e_2 &amp; -e_1e_2 &amp; -e_1e_2N \newline 0 &amp; 0 &amp; 0 &amp; e_3 &amp; -e_3N &amp; -e_3N &amp; e_3N^3 \newline 0 &amp; 0 &amp; 0 &amp; 0 &amp; e_1e_3 &amp; 0 &amp; -e_1e_3N \newline 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; e_2e_3 &amp; -e_2e_3N \newline 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; e_1e_2e_3 \end{matrix}\right] \times D$$</p> <p>其中 $$D={\rm diag}(N^{3/2},N,N^{(3/2)+\alpha_3},N^{1/2},N^{(3/2)+\alpha_3},N^{1+\alpha_3},N^{1+\alpha_3}，1)$$</p> <p>参考：<a href=https://furutsuki.hatenablog.com/entry/2020/07/26/185243>3kCTF - RSA Textbook</a></p> <pre><code>from sage.all import *
import gmpy2

N = 
e1 = 
e2 = 
e3 = 
c = 

for i in range(1000):
    alpha2 = i/1000
    M1 = int(gmpy2.mpz(N)**(3./2))
    M2 = int( gmpy2.mpz(N) )
    M3 = int(gmpy2.mpz(N)**(3./2 + alpha2))
    M4 = int( gmpy2.mpz(N)**(0.5) )
    M5 = int( gmpy2.mpz(N)**(3./2 + alpha2) )
    M6 = int( gmpy2.mpz(N)**(1.+alpha2) )
    M7 = int( gmpy2.mpz(N)**(1.+alpha2) )
    D = diagonal_matrix(ZZ, [M1, M2, M3, M4, M5, M6, M7, 1])
    B = Matrix(ZZ, [ [1, -N,   0,  N**2,   0,      0,      0,    -N**3],
                 [0, e1, -e1, -e1*N, -e1,      0,   e1*N,  e1*N**2],
                 [0,  0,  e2, -e2*N,   0,   e2*N,      0,  e2*N**2],
                 [0,  0,   0, e1*e2,   0, -e1*e2, -e1*e2, -e1*e2*N],
                 [0,  0,   0,     0,  e3,  -e3*N,  -e3*N,  e3*N**2],
                 [0,  0,   0,     0,   0,  e1*e3,      0, -e1*e3*N],
                 [0,  0,   0,     0,   0,      0,  e2*e3, -e2*e3*N],
                 [0,  0,   0,     0,   0,      0,      0, e1*e2*e3] ]) * D

    L = B.LLL()

    v = Matrix(ZZ, L[0])
    x = v * B**(-1)
    phi_ = (e1*x[0,1]/x[0,0]).floor()
    try:
        d = inverse_mod( 65537, phi_)
        m = hex(power_mod(c, d, N))[2:]
        if m.startswith('44415343'):
            print(i)
            print(bytes.fromhex(m))
            break
    except:
        pass
</code></pre> <ul> <li><strong>给定更多组</strong></li> </ul> <p><a href=https://www.ctfer.vip/#/note/set/wp/51>西湖论剑 2021 - WienerStudyTwice</a> * 参考Paper</p> <p><a href=https://eprint.iacr.org/2009/037.pdf>Common Modulus Attacks on Small Private Exponent RSA and Some Fast Variants (in Practice)</a></p> <p><a href=https://0xdktb.top/2020/05/04/WriteUp-De1CTF2020-Crypto/howgrave-graham1999.pdf>Extending Wiener’s Attack in the Presence of Many Decrypting Exponents</a></p> <p>​</p> <h4 id=rsa>多项式RSA</h4> <p>在整数RSA原理基础上将多项式代入分析：</p> <p>在有限域上选取两个不可约多项式 $$g(p),g(q)$$，$$g(n)=g(p) \cdot g(q)$$，计算出 $$g(n)$$ 的欧拉函数 $$\varphi(g(n))=\varphi$$，</p> <p>选取一个整数 $$e$$ 作为公钥，$$e$$ 与 $$\varphi$$ 是互素的，那么对于明文 $$g(m)$$，加密过程为 $$g(m)^e \equiv g(c) \pmod {g(n)}$$，</p> <p>计算私钥 $$d$$ 满足 $$ed \equiv 1 \pmod \varphi$$，则 $$g(c)^d \equiv (g(m)^e)^d \equiv g(m)^{ed} \equiv g(m)^{\varphi+1} \pmod {g(n)}$$，</p> <p>同样考虑 $$g(n)$$ 与 $$g(m)$$ 互素，欧拉定理对于多项式亦成立，</p> <p>得到 $$g(m)^{\varphi+1} \equiv g(m) \pmod {g(n)}$$，所以 $$g(c)^d \equiv g(m) \pmod {g(n)}$$。</p> <p>显然RSA对于整数的体制可以适用于有限域上的多项式。</p> <p><strong>★注意：</strong></p> <p>对于素数 $$x$$，$$\varphi(x)=x-1$$，但是对于不可约多项式 $$g(x)$$，$$\varphi(g(x))=p^n-1$$。（此 $$p$$ 为 $$GF(p)$$ 的模，此 $$n$$ 为多项式最高项次数）</p> <p>原因：</p> <p>由欧拉函数定义本身，欧拉函数是小于 $$n$$ 的所有与 $$n$$ 互质的数的个数。</p> <p>多项式的欧拉函数则类似，表示不高于 $$g(x)$$ 幂级的环内所有多项式中，与 $$g(x)$$ 无公因式（非1）的其他多项式的个数，所以每一个不高于 $$g(x)$$ 幂级的环内多项式（除了它自己）均满足此条件。</p> <pre><code>#脚本1
#Sage
#已知p,n,m^e
p= 
P = PolynomialRing(Zmod(p), name = 'x')
x = P.gen()
e = 
n = 
c =

#分解N
q1, q2 = n.factor()
q1, q2 = q1[0], q2[0]

#求φ，注意求法，
phi = (p**q1.degree() - 1) * (p**q2.degree() - 1)
assert gcd(e, phi) == 1
d = inverse_mod(e, phi)
m = pow(c,d,n)

#取多项式系数
flag = bytes(m.coefficients())
print(&quot;Flag: &quot;, flag.decode())
</code></pre> <pre><code>#脚本2
#Sage
#已知p=2,n,e,c
p = 
P = PolynomialRing(GF(p), name = 'x')
x = P.gen()
e = 
n = 
R.&lt;a&gt; = GF(2^2049)
c = []

q1, q2 = n.factor()
q1, q2 = q1[0], q2[0]

phi = (p**q1.degree() - 1) * (p**q2.degree() - 1)
assert gcd(e, phi) == 1
d = inverse_mod(e, phi)

ans = ''
for cc in c:
    cc = P(R.fetch_int(cc))
    m = pow(cc,d,n)
    m = R(P(m)).integer_representation()
    print(m)
    ans += chr(m)
print(ans)
</code></pre> <p>参考：</p> <p><a href=https://xz.aliyun.com/t/4545>0ctf - babyrsa</a></p> <p><a href=https://blog.csdn.net/cccchhhh6819/article/details/103563019>watevrCTF 2019 - Swedish RSA</a></p> <p><a href=https://github.com/S3v3ru5/CTF-writeups/tree/master/Inctfi-2020>InCTF 2020 - PolyRSA</a></p> <p><a href=http://www.diva-portal.se/smash/get/diva2:823505/FULLTEXT01.pdf>Polynomial based RSA</a></p> <p>​</p> <h4 id=weak-prime-factors-p>Weak prime factors （p具线性特征）</h4> <p><strong>适用情况：$$p$$ 满足 $$ap=u_0+M_1u_1+\cdots+M_ku_k$$</strong></p> <p>先根据 $$n$$ 确定 $$M$$ 的大小，再根据 $$M$$ 选取符合要求的 $$k$$ 和 $$c$$，然后构造一个格如下：</p> <p>$$M(\mathcal{L})=\begin{bmatrix}{1}&amp;{0}&amp;{0}&amp;{\cdots}&amp;{0}&amp;{CM^{2k}} \newline<br> {0}&amp;{1}&amp;{0}&amp;{\cdots}&amp;{0}&amp;{CM^{2k-1}} \newline {\vdots}&amp;{\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}&amp;{\vdots} \newline {0}&amp;{0}&amp;{0}&amp;{\cdots}&amp;{1}&amp;{CM} \newline {0}&amp;{0}&amp;{0}&amp;{\cdots}&amp;{0}&amp;{-CN} \newline \end{bmatrix}$$</p> <p>用LLL算法进行格基规约，将规约后的某个向量作为多项式系数，再对多项式进行分解，即可完成对 $$n$$ 的分解。</p> <ul> <li>参考</li> </ul> <p><a href=https://eprint.iacr.org/2015/398.pdf>Factoring RSA moduli with weak prime factors</a></p> <p>N1CTF2020 - easyRSA</p> <pre><code>from tqdm import tqdm
import gmpy2

class success(Exception):
    pass

def attack_weak_prime(basenum, exp, n):
    m = basenum^exp
    k = len(n.str(base=basenum))//(2*exp) + 1
    c = gmpy2.iroot(2*k^3, int(2))
    # assert c[1] == True
    tmp = int(c[0])

    try:
        for c in tqdm(range(1, tmp)):
            amount = 2*k+1

            M = Matrix(RationalField(), amount, amount)
            for i in range(amount):
                M[i, i] = 1
                M[i, amount-1] = c*m^(2*k-i)
            M[amount-1, amount-1] = -c*n

            new_basis = M.LLL(delta=0.75)
            for j in range(amount):
                last_row = list(new_basis[j])
                last_row[-1] = last_row[-1]//(-c)

                poly = sum(e * x^(k*2-i) for i,e in enumerate(last_row))
                fac = poly.factor_list()
                if len(fac) == 2:
                    p_poly, q_poly = fac
                    p_coefficient = p_poly[0].list()
                    q_coefficient = q_poly[0].list()
                    ap = sum(m^i * j for i,j in enumerate(p_coefficient))
                    bq = sum(m^i * j for i,j in enumerate(q_coefficient))
                    p = gcd(ap, n)
                    q = gcd(bq, n)

                    if (p*q == n) and (p != 1) and (q != 1):
                        raise success

    except:
        print ('n =', n)
        print ('p =', p)
        print ('q =', q)
        print ('p*q == n ?', bool(p*q == n))


if __name__ == '__main__':
    print ('[+] Weak Prime Factorization Start!')
    print ('-------------------------------------------------------------------------------------------------------------------------------')
    basenum, exp = (3, 66)
    n = 32846178930381020200488205307866106934814063650420574397058108582359767867168248452804404660617617281772163916944703994111784849810233870504925762086155249810089376194662501332106637997915467797720063431587510189901

</code></pre> <p>​</p> <h4 id=_6>其他特别情形</h4> <ul> <li> <h5 id=multi-prime-rsa>多素数因子（Multi-prime RSA）</h5> </li> </ul> <p>$$n=p_1^{k_1}p_2^{k_2}\cdots p_m^{k_m} \ \Rightarrow \begin{eqnarray}\varphi(n) &amp;=&amp;\varphi(p_1^{k_1})\varphi(p_2^{k_2}) \cdots \varphi(p_m^{k_m}) \ &amp;=&amp;(p_1^{k_1-1}\cdot(p_1-1))(p_2^{k_2-1}\cdot(p_2-1)) \cdots (p_m^{k_m-1}\cdot(p_m-1)) \end{eqnarray}$$</p> <p>​ * ##### next_prime()</p> <blockquote> <p>根据素数定理，素数的平均间隔为：$$\cfrac{x}{\pi(x)} \approx \ln(x)$$，因此常见的下一个素数比当前素数大一点，一般不会超过1500。</p> </blockquote> <ul> <li><strong>变种1</strong>：$$n=p \cdot q \cdot \text{nextprime}(p) \cdot \text{nextprime}(q)$$</li> </ul> <p><a href=https://lazzzaro.github.io/2020/05/10/crypto-crypto%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/#%E8%B4%B9%E9%A9%AC%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3>费马因式分解</a>。​ * <strong>给 e,p,c</strong></p> <p>$$c \equiv m^e \pmod n \ \Leftrightarrow c_1 \equiv c \pmod p \equiv m^e \pmod p$$</p> <p>令 $$ed_1 \equiv 1 \pmod {(p-1)}$$，有 $$m \equiv c^d \pmod n \equiv c_1^{d_1} \pmod p$$。</p> <p>​ * ##### <strong>给 e,d,modinv(q,p),c</strong></p> <p>已知：$$p,q$$ 同比特位数。</p> <p>令 $$cf=q^{-1} \bmod p$$，有 $$q\cdot cf=1 \pmod p$$。</p> <ul> <li>$$ed=1+k(p-1)(q-1)$$，</li> </ul> <p>比较比特位数，$$k$$ 与 $$e$$ 同长，可爆破 $$k$$，得 $$\varphi(n)=(p-1)(q-1)=\cfrac{ed-1}{k}$$； + 上式 $$\varphi(n) =(p-1)(q-1) \pmod p=-(q-1) \pmod p$$，</p> <p>结合 $$q\cdot cf=1 \pmod p$$，即 $$q\cdot cf-1=0 \pmod p$$，</p> <p>联立：</p> <p>$$\begin{eqnarray} \varphi(n)&amp;=&amp;(p-1)(q-1) \ &amp;=&amp;pq-p-q+1 \ &amp;=&amp;n-p-q+1 \end{eqnarray}$$</p> <p>$$\begin{eqnarray} cf\cdot \varphi(n)&amp;=&amp;cf\cdot(n-p-q+1) \ &amp;=&amp;cf\cdot n-cf\cdot p-cf\cdot q+cf \end{eqnarray}$$</p> <p>$$\begin{eqnarray} cf\cdot \varphi(n) \bmod p&amp;=&amp;(cf\cdot n-cf\cdot p-cf\cdot q+cf) \bmod p \ &amp;=&amp;0-0-(cf\cdot q)+cf \bmod p \ &amp;=&amp;-1+cf \bmod p \end{eqnarray}$$</p> <p>有 $$1+cf\cdot \varphi(n)-cf=0\pmod p$$，</p> <p>即$$x=1+cf\cdot \varphi(n)-cf$$ 能被 $$p$$ 整除； + 由费马小定理，存在 $$r$$ 满足 $$r^{p-1}=1 \pmod p$$，</p> <p>$$\begin{eqnarray}r^{\varphi(n)}&amp;=&amp;(r^{(p-1)})^{(q-1)} \ &amp;=&amp;1^{(q-1)} \pmod p \ &amp;=&amp;1 \pmod p \end{eqnarray}$$，</p> <p>因对于任意 $$r,k_1,k_2$$，当 $$k_2$$ 为 $$k_1$$ 因子时，$$r \bmod k_2=(r \bmod k_1) \bmod k_2$$，</p> <p>故 $$r^{\varphi(n)} \bmod p=(r^{\varphi(n)} \bmod x) \bmod p=1 \bmod p=kp$$，</p> <p>已知 $$\varphi(n)$$，由 $$(r^{\varphi(n)} \bmod x) \bmod p=kp$$ 可得到多组 $$p$$ 的乘积，计算 $$\gcd$$ 可得到 $$p$$； + 由 $$q\cdot cf=1 \pmod p$$ 求模逆可得 $$q$$，再用 $$c$$ 计算出 $$m$$。</p> <p>参考：<a href=https://gist.github.com/n-ari/a2db9af7fd3c172e4fa65b923a66beff>TSG CTF 2020 - Modulus Amittendus</a>​ * ##### <strong>gcd(e,φ(n)) ≠ 1</strong></p> <p>$$\gcd(e,\varphi(n))\neq 1$$ 时，$$e$$ 与 $$\varphi(n)$$ 不互素，</p> <p>$$m^e \equiv (m^{\gcd(e,\varphi(n))})^{\frac{e}{\gcd(e,\varphi(n))}} \equiv c \pmod n$$，计算 $$\frac{e}{\gcd(e,\varphi(n))}$$ 的模逆 $$d’$$，</p> <p>则 $$c^{d’}\equiv m^{\gcd(e,\varphi(n))}\pmod n$$。</p> <p>当 $$\gcd(e,\varphi(n))$$ 较小时，可以直接对 $$c$$ 开根，有两种情况：</p> <ul> <li>$$m^e = c&lt;n$$，这种情况直接对 $$c$$ 开 $$e$$ 次方即可；</li> <li>$$m^e = c&gt;n$$，这种情况需要在有限域下对 $$c$$ 开方，一般先计算 $$c_p=c \bmod p$$，$$c_q=c \bmod q$$，分别求出 $$c_p,c_q$$ 在 $$c$$ 下的 $$e$$ 次根（可能有多个），然后使用CRT遍历所有组合，分别check得出明文。当 $$\gcd(e,\varphi(n))$$ 较大时，求 $$p,q$$ 的 $$e$$ 次根步骤需要替换为一些有限域开根的高效算法（如AMM算法等）进行计算。</li> </ul> <p>参考：</p> <p><a href=https://github.com/De1ta-team/De1CTF2019/blob/master/writeup/crypto/Baby%20Rsa/README_zh.md>De1CTF2019 - Baby RSA</a></p> <p><a href=https://github.com/p4-team/ctf/tree/master/2016-03-12-0ctf/rsa>0ctf 2016 - RSA?</a></p> <p>​ * ##### <strong>e|(p-1), e|(q-1)</strong></p> <p>上面的 $$\gcd(e,\varphi(n))\neq 1$$ 情况不针对 $$\gcd(e,\varphi(n))= e$$，这里对 $$e\mid (p-1),e\mid (q-1)$$ 的特殊情况进行讨论。</p> <p>解题思路即求解 $$m \bmod p$$ 和 $$m \bmod q$$ ，再通过CRT还原 $$m \bmod n$$。主要难点则是在 $$\text{GF}(p)$$ 上求 $$e$$ 次根。</p> <p>在有限域上求r-th root有两个常见算法（Adleman-Manders-Miller algorithm和Cipolla-Lehmer algorithm），Namhun Koo提出一种更具一般性的开根算法，且在 $$s$$ 足够小的时候更高效（$$r^{s}\mid (p-1),r^{s}\nmid (p-1)$$）。</p> <p>★<strong>参考</strong>：<a href="http://yulige.top/?p=752#easyRSA909pt_2solvers">NCTF 2019 - easyRSA</a> （<a href=https://arxiv.org/pdf/1111.4877.pdf>Adleman-Manders-Miller rth Root Extraction Method</a>）</p> <p>本题则为 $$e$$ 和 $$p-1$$ （或 $$q-1$$）的最大公约数就是 $$e$$ 本身，也就是说 $$e\mid (p-1)$$，只有对 $$c$$ 开 $$e$$ 次方根才行。</p> <p>可以将同余方程 $$m^e \equiv c \pmod n$$ 化成</p> <p>$$\begin{cases} m^e \equiv c \pmod p \ m^e \equiv c \pmod q \end{cases}$$</p> <p>然后分别在 $$\text{GF}(p)$$ 和 $$\text{GF}(q)$$ 上对 $$c$$ 开 $$e$$ 次方根，再用CRT组合一下即可得到在 $$\bmod n$$ 下的解。</p> <p>问题是，<strong>如何在有限域内开根</strong>？</p> <p>这里 $$e$$ 与 $$p-1$$ 和 $$q-1$$ 都不互素，不能简单地求个逆元就完事。</p> <p>这种情况下，<strong>开平方根</strong>可以用<code>Tonelli–Shanks algorithm</code>，<a href=https://en.wikipedia.org/wiki/Tonelli–Shanks_algorithm>Wiki</a>说这个算法可以<strong>扩展到开n次方根</strong>。</p> <p>在这篇<a href=https://arxiv.org/pdf/1111.4877.pdf>paper</a>里给出了具体的算法：<code>Adleman-Manders-Miller rth Root Extraction Method</code>。</p> <p>这个算法只能开出一个根，实际上开 $$e$$ 次方，最多会有 $$e$$ 个根（这题的情况下有0x1337个根）。</p> <p>如何找到其他根？</p> <p><a href=https://stackoverflow.com/questions/6752374/cube-root-modulo-p-how-do-i-do-this>StackOverflow – Cube root modulo P</a> 给出了方法。</p> <p>如何找到所有的<code>primitive 0x1337th root of 1</code>?</p> <p><a href=https://crypto.stackexchange.com/questions/63614/finding-the-n-th-root-of-unity-in-a-finite-field>StackExchange – Finding the n-th root of unity in a finite field</a> 给出了方法。</p> <p><strong>Exploit</strong>（以 <code>e=0x1337</code>​ 为例）</p> <ul> <li>先用<code>Adleman-Manders-Miller rth Root Extraction Method</code>在 $$\text{GF}(p)$$ 和 $$\text{GF}(q)$$ 上对 $$c$$ 开 $$e$$ 次方根，分别得到一个解。大概不到10秒。</li> <li>然后去找到所有的<code>0x1336</code>个<code>primitive nth root of 1</code>，乘以上面那个解，得到所有的<code>0x1337</code>个解。大概1分钟。</li> <li>再用CRT对 $$\text{GF}(p)$$ 和 $$\text{GF}(q)$$ 上的两组<code>0x1337</code>个解组合成 $$\bmod n$$ 下的解，可以得到<code>0x1337**2=24196561</code>个 $$\bmod n$$ 的解。最后能通过<code>check()</code>的即为flag。大概十几分钟。</li> </ul> <pre><code>#脚本1
#Sage
import random
import time

# About 3 seconds to run
def AMM(o, r, q):
    start = time.time()
    print('\n----------------------------------------------------------------------------------')
    print('Start to run Adleman-Manders-Miller Root Extraction Method')
    print('Try to find one {:#x}th root of {} modulo {}'.format(r, o, q))
    g = GF(q)
    o = g(o)
    p = g(random.randint(1, q))
    while p ^ ((q-1) // r) == 1:
        p = g(random.randint(1, q))
    print('[+] Find p:{}'.format(p))
    t = 0
    s = q - 1
    while s % r == 0:
        t += 1
        s = s // r
    print('[+] Find s:{}, t:{}'.format(s, t))
    k = 1
    while (k * s + 1) % r != 0:
        k += 1
    alp = (k * s + 1) // r
    print('[+] Find alp:{}'.format(alp))
    a = p ^ (r**(t-1) * s)
    b = o ^ (r*alp - 1)
    c = p ^ s
    h = 1
    for i in range(1, t):
        d = b ^ (r^(t-1-i))
        if d == 1:
            j = 0
        else:
            print('[+] Calculating DLP...')
            j = - discrete_log(a, d)
            print('[+] Finish DLP...')
        b = b * (c^r)^j
        h = h * c^j
        c = c ^ r
    result = o^alp * h
    end = time.time()
    print(&quot;Finished in {} seconds.&quot;.format(end - start))
    print('Find one solution: {}'.format(result))
    return result

def findAllPRoot(p, e):
    print(&quot;Start to find all the Primitive {:#x}th root of 1 modulo {}.&quot;.format(e, p))
    start = time.time()
    proot = set()
    while len(proot) &lt; e:
        proot.add(pow(random.randint(2, p-1), (p-1)//e, p))
    end = time.time()
    print(&quot;Finished in {} seconds.&quot;.format(end - start))
    return proot

def findAllSolutions(mp, proot, cp, p):
    print(&quot;Start to find all the {:#x}th root of {} modulo {}.&quot;.format(e, cp, p))
    start = time.time()
    all_mp = set()
    for root in proot:
        mp2 = mp * root % p
        assert(pow(mp2, e, p) == cp)
        all_mp.add(mp2)
    end = time.time()
    print(&quot;Finished in {} seconds.&quot;.format(end - start))
    return all_mp


c = 10562302690541901187975815594605242014385201583329309191736952454310803387032252007244962585846519762051885640856082157060593829013572592812958261432327975138581784360302599265408134332094134880789013207382277849503344042487389850373487656200657856862096900860792273206447552132458430989534820256156021128891296387414689693952047302604774923411425863612316726417214819110981605912408620996068520823370069362751149060142640529571400977787330956486849449005402750224992048562898004309319577192693315658275912449198365737965570035264841782399978307388920681068646219895287752359564029778568376881425070363592696751183359
p = 199138677823743837339927520157607820029746574557746549094921488292877226509198315016018919385259781238148402833316033634968163276198999279327827901879426429664674358844084491830543271625147280950273934405879341438429171453002453838897458102128836690385604150324972907981960626767679153125735677417397078196059
q = 112213695905472142415221444515326532320352429478341683352811183503269676555434601229013679319423878238944956830244386653674413411658696751173844443394608246716053086226910581400528167848306119179879115809778793093611381764939789057524575349501163689452810148280625226541609383166347879832134495444706697124741
e = 0x1337
cp = c % p
cq = c % q
mp = AMM(cp, e, p)
mq = AMM(cq, e, q)
p_proot = findAllPRoot(p, e)
q_proot = findAllPRoot(q, e)
mps = findAllSolutions(mp, p_proot, cp, p)
mqs = findAllSolutions(mq, q_proot, cq, q)
print(mps, mqs)

def check(m):
    h = m.hex()
    if len(h) &amp; 1:
        return False
    if bytes.fromhex(h).startswith(b'NCTF'):
        print(bytes.fromhex(h))
        return True
    else:
        return False


# About 16 mins to run 0x1337^2 == 24196561 times CRT
start = time.time()
print('Start CRT...')
for mpp in mps:
    for mqq in mqs:
        solution = CRT_list([int(mpp), int(mqq)], [p, q])
        if check(solution):
            print(solution)
    print(time.time() - start)

end = time.time()
print(&quot;Finished in {} seconds.&quot;.format(end - start))

</code></pre> <pre><code>#脚本2
#Sage
c = 346925245648012783854132941104554194717281878370806475831055718275298366664505658836564073456294047402009856656647760
p = 21122913513992623721920275602985463699928507831138027
q = 16471885912035642894544190467774867069446937372970845578732298073
e = 239

P.&lt;a&gt;=PolynomialRing(Zmod(p),implementation='NTL')
f=a^e-c
mps=f.monic().roots()

P.&lt;a&gt;=PolynomialRing(Zmod(q),implementation='NTL')
g=a^e-c
mqs=g.monic().roots()

for mpp in mps:
    x=mpp[0]
    for mqq in mqs:
        y=mqq[0]
        solution = hex(CRT_list([int(x), int(y)], [p, q]))[2:]
        if solution.startswith('666c'):
            print(solution)
</code></pre> <p>​ * ##### <strong>SMUPE 问题</strong>（不同N,e加密线性关系明文）</p> <p>a system of univariate polynomial equations problem = 一元多项式方程组求解问题</p> <ul> <li><strong>定义</strong></li> </ul> <p>$$k$$ 是一个整数，$$N$$ 为满足RSA算法的模数，$$\delta$$ 是多项式的阶。有</p> <p>$$N_i&lt;N_{i+1},\delta_i \in N\quad(i=1,2,\cdots,k)$$</p> <p>多项式方程组表示如下, 目的是求解 $$x$$：</p> <p>$$\begin{cases} f_1(x)\equiv 0 \pmod {N_1}\newline f_2(x)\equiv 0 \pmod {N_2} \newline {\vdots} \newline f_k(x)\equiv 0 \pmod {N_k} \end{cases}$$ + <strong>求解条件</strong></p> <p>Alexander May, Maike Ritzenhofent提出一种求解方法，简单地说当多项式的阶 $$\delta$$ 满足以下情况时可解（$$\delta$$ 是多项式的阶）：</p> <p>$$\sum\limits_{i=1}^k \cfrac{1}{\delta_i} \geq 1$$</p> <p><strong>具体描述：</strong></p> <p>令 $$(f_i,\delta_i,N_i) \quad(i=1,2,\cdots,k)$$ 作为SMUPE问题的首一多项式组，</p> <p>定义 $$M=\prod\limits_{i=1}^k N_i^{\frac{\delta}{\delta_i}},\delta=\text{lcm}(\delta_i) \quad (i=1,2,\cdots,k)$$</p> <p>则SMUPE问题可以在 $$O(\delta^6\cdot \log_2M)$$ 复杂度解决。参考：<a href=https://xz.aliyun.com/t/6813#toc-9>2019红帽杯 - 精明的Alice</a></p> <p>​ * ##### 反素数（emirp数）</p> <p>已知：$$q=\text{reverse_x}(p)$$，$$\text{x}$$ 为进制数。</p> <p>爆破思路类似RSA parity oracle。$$p,q$$ 是bit翻转关系，已知 $$p$$ 最低的 $$k$$ 位，则已知 $$q$$ 最高的 $$k$$ 位。</p> <p>假设已知 $$k$$ 位的 $$p,q$$，记为 $$ph,qh$$，利用不等式</p> <p>$$ph\cdot qh\cdot 2^{1024-2k}&lt;=n&lt;(ph+1)\cdot(qh+1)\cdot 2^{1024-2k}$$ ，</p> <p>逐位向低地址爆破，不断收缩不等式的范围，最终可求得 $$n$$ 值。</p> <p>参考：</p> <p><a href=https://kt.gy/blog/2015/10/asis-2015-finals-rsasr/ >ASIS 2015 Finals: RSASR</a></p> <p><a href=https://mcfx.us/archives/281/#h2-rsa_yay>Midnight Sun CTF 2020 Quals</a></p> <p>RoarCTF 2020 - Reverse</p> <pre><code>#python2
#x=10
n = 6528060431134312098979986223024580864611046696815854430382374273411300418237131352745191078493977589108885811759425485490763751348287769344905469074809576433677010568815441304709680418296164156409562517530459274464091661561004894449297362571476259873657346997681362092440259333170797190642839587892066761627543
def t(a, b, k):
    # sqrt(n) has 155 digits, so we need to figure out 77 digits on each side
    if k == 77:
        if a*b == n:
            print a, b
        return
    for i in xrange(10):
        for j in xrange(10):
            # we try to guess the last not-already-guessed digits of both primes
            a1 = a + i*(10**k) + j*(10**(154-k))
            b1 = b + j*(10**k) + i*(10**(154-k))
            if a1*b1 &gt; n:
                # a1 and b1 are too large
                continue
            if (a1+(10**(154-k)))*(b1+(10**(154-k))) &lt; n:
                # a1 and b1 are too small
                continue
      if ((a1*b1)%(10**(k+1))) != (n%(10**(k+1))):
                # The last digits of a1*b1 (which won't change later) doesn't match n
          continue
            # this a1 and b1 seem to be a possible match, try to guess remaining digits
        t(a1, b1, k+1)

# the primes have odd number of digits (155), so we try all possible middle digits (it simplifies the code)
for i in xrange(10):
    t(i*(10**77), i*(10**77), 0)
</code></pre> <p>​ * ##### 4p-1 method</p> <p>对使用一类特定素数乘积的模数的分解。</p> <p>当一类特殊的素数用在 RSA 模数中时，可以轻易的将该素数从 $$n$$ 中分解出来。由于这一类素数都形如 $$4p−1=Ds^2$$，因此又被称为 <code>4p-1 method</code>。此外，有些人也会将其视为 RSA 的后门之一，称之为 <code>RSA backdoor</code>。</p> <ul> <li><strong>QiCheng Prime</strong></li> </ul> <p>$$Ds={3,11,19,43,67,163}$$</p> <pre><code>import sys

sys.setrecursionlimit(10^6)

def QiCheng(n):
    R = Integers(n)
    attempts = 20
    js = [0, (-2^5)^3, (-2^5*3)^3, (-2^5*3*5)^3, (-2^5*3*5*11)^3, (-2^6*3*5*23*29)^3]

    for _ in range(attempts):
        for j in js:
            if j == 0:
                a = R.random_element()
                E = EllipticCurve([0, a])

            else:
                a = R(j)/(R(1728)-R(j))
                c = R.random_element()
                E = EllipticCurve([3*a*c^2, 2*a*c^3])

            x = R.random_element()
            z = E.division_polynomial(n, x)
            g = gcd(z, n)
            if g &gt; 1:
                return g

n = 
p = int(QiCheng(Integer(n)))
</code></pre> <ul> <li><strong>Masaaki Shirase &amp; Vladimir Sedlacek Improvement</strong></li> </ul> <p>更多 $$Ds$$ 值。</p> <p><a href=https://github.com/crocs-muni/cm_factorization>CM-based factorization</a>参考：</p> <p><a href=https://blog.arpe1s.xyz/posts/2021/03/qicheng_prime/ >浅谈 QiCheng Prime</a></p> <p>NCTF 2020 - RSA_revenge</p> <p>CryptoHack Challenge - RSA Backdoor Viability</p> <p>​ * ##### Common Prime RSA</p> <p><strong>情形：$$\gcd(p-1,q-1)=g$$</strong></p> <p>分解的n方法有四种：</p> <p>（1）修改Pollard’s rho方法分解n；</p> <p>（2）知道a、b的值分解n；</p> <p>（3）知道g的值分解n；</p> <p>（4）分解N-1。</p> <pre><code># Pollard’s rho
def f(x, n):
    return (pow(x, n - 1, n) + 3) % n
def rho(n):
    i = 1
    print 'Factorizing'
    while True:
        x1 = getRandomRange(2, n)
        x2 = f(x1, n)
        j = 1
        while True:
            p = gmpy2.gcd(abs(x1 - x2), n)
            if p == n:
                break
            elif p &gt; 1 and isPrime(p):
                print 'Found!'
                return (p, n // p)
else:
                x1 = f(x1, n)
                x2 = f(f(x2, n), n)
            j += 1
        i += 1

</code></pre> <h3 id=_7>详细原理</h3> <p><a href=https://paper.seebug.org/727/ >二十年以来对 RSA 密码系统攻击综述</a></p> <p><a href=https://ctf-wiki.github.io/ctf-wiki/crypto/asymmetric/rsa/rsa_theory-zh/ >CTF Wiki - RSA</a></p> <p><a href=https://0xdktb.top/2020/02/28/Summary-of-Crypto-in-CTF-RSA/ >0xDktb’s Blog</a></p> <p><a href=https://ohmygodlin.github.io/ctf/crypto/2018/09/26/RSA%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/ >RSA常见攻击方法</a></p> <p><a href="http://index-of.es/Varios-2/Cryptanalysis of RSA and It's Variants.pdf">Cryptanalysis of RSA and It’s Variants</a></p> <p>原文链接： <a href=https://lazzzaro.github.io/2020/05/06/crypto-RSA/index.html>https://lazzzaro.github.io/2020/05/06/crypto-RSA/index.html</a></p> </article> </div> </div> </main> <footer class=md-footer> <nav class="md-footer__inner md-grid" aria-label=页脚> <a href=../CTF%E5%B8%B8%E7%94%A8RSA%E6%8A%80%E5%B7%A7/ class="md-footer__link md-footer__link--prev" aria-label="上一页: CTF常用RSA技巧" rel=prev> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </div> <div class=md-footer__title> <div class=md-ellipsis> <span class=md-footer__direction> 上一页 </span> CTF常用RSA技巧 </div> </div> </a> <a href=../SageMath%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/ class="md-footer__link md-footer__link--next" aria-label="下一页: SageMath常用函数" rel=next> <div class=md-footer__title> <div class=md-ellipsis> <span class=md-footer__direction> 下一页 </span> SageMath常用函数 </div> </div> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg> </div> </a> </nav> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> <div class=md-copyright__highlight> Copyright &copy; 2022 - 3022 <span style=float:right><a href=http://beian.miit.gov.cn/ >鄂ICP备19027194号-2</a></span> </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../..", "features": ["navigation.tabs", "navigation.tabs.sticky", "search.suggest", "search.highlight", "search.share"], "translations": {"clipboard.copy": "\u590d\u5236", "clipboard.copied": "\u5df2\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\uff0c\\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.term.missing": "\u7f3a\u5c11", "select.version.title": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "search": "../../assets/javascripts/workers/search.bd0b6b67.min.js"}</script> <script src=../../assets/javascripts/bundle.8aa65030.min.js></script> </body> </html>