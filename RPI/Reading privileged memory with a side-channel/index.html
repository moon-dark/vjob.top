<!doctype html><html lang=zh class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=http://vjob.top/RPI/Reading%20privileged%20memory%20with%20a%20side-channel/ rel=canonical><link rel=icon href=../../assets/images/favicon.png><meta name=generator content="mkdocs-1.2.3, mkdocs-material-8.2.1"><title>Reading privileged memory with a side channel - 微站</title><link rel=stylesheet href=../../assets/stylesheets/main.e8d9bf0c.min.css><link rel=stylesheet href=../../assets/stylesheets/palette.e6a45f82.min.css><meta name=theme-color content=#ffffff><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Noto+Sans:300,400,400i,700%7CSource+Code+Pro&display=fallback"><style>:root{--md-text-font:"Noto Sans";--md-code-font:"Source Code Pro"}</style><script>__md_scope=new URL("../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=preference data-md-color-primary=white data-md-color-accent=red> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#reading-privileged-memory-with-a-side-channel class=md-skip> 跳转至 </a> </div> <div data-md-component=announce> </div> <header class="md-header md-header--lifted" data-md-component=header> <nav class="md-header__inner md-grid" aria-label=页眉> <a href=../.. title=微站 class="md-header__button md-logo" aria-label=微站 data-md-component=logo> <img src=../../static/img/avatar.png alt=logo> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> 微站 </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> Reading privileged memory with a side channel </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=搜索 placeholder=搜索 autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </label> <nav class=md-search__options aria-label=查找> <a href=javascript:void(0) class="md-search__icon md-icon" aria-label=分享 data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08z"/></svg> </a> <button type=reset class="md-search__icon md-icon" aria-label=清空当前内容 tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg> </button> </nav> <div class=md-search__suggest data-md-component=search-suggest></div> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> 正在初始化搜索引擎 </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> </nav> <nav class=md-tabs aria-label=标签 data-md-component=tabs> <div class="md-tabs__inner md-grid"> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../.. class=md-tabs__link> 主页 </a> </li> <li class=md-tabs__item> <a href=../%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85Ubuntu%20mate15.10-%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0_machh%E7%9A%84%E4%B8%93%E6%A0%8F-CSDN%E5%8D%9A%E5%AE%A2/ class="md-tabs__link md-tabs__link--active"> 树莓派 </a> </li> <li class=md-tabs__item> <a href=../../Android/Android%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E5%92%8Croot%E6%9D%83%E9%99%90/ class=md-tabs__link> Android </a> </li> <li class=md-tabs__item> <a href=../../Bash/%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84Linux%E6%8A%80%E5%B7%A7/ class=md-tabs__link> Bash </a> </li> <li class=md-tabs__item> <a href=../../Python/python%E5%88%B6%E4%BD%9Cpdf%E7%94%B5%E5%AD%90%E4%B9%A6/ class=md-tabs__link> Python </a> </li> <li class=md-tabs__item> <a href=../../%E7%AE%97%E6%B3%95/ class=md-tabs__link> 算法 </a> </li> <li class=md-tabs__item> <a href=../../other/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/ class=md-tabs__link> 安全 </a> </li> <li class=md-tabs__item> <a href=../../other/TOP%2011%20Deep%20Web%20Search%20Engine%20Alternative%20for%20Google%20and%20Bing%202021/ class=md-tabs__link> 其它 </a> </li> </ul> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=导航栏 data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../.. title=微站 class="md-nav__button md-logo" aria-label=微站 data-md-component=logo> <img src=../../static/img/avatar.png alt=logo> </a> 微站 </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_1 type=checkbox id=__nav_1> <label class=md-nav__link for=__nav_1> 主页 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=主页 data-md-level=1> <label class=md-nav__title for=__nav_1> <span class="md-nav__icon md-icon"></span> 主页 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../.. class=md-nav__link> 微站 </a> </li> <li class=md-nav__item> <a href=../%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85Ubuntu%20mate15.10-%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0_machh%E7%9A%84%E4%B8%93%E6%A0%8F-CSDN%E5%8D%9A%E5%AE%A2/ class=md-nav__link> 树莓派 </a> </li> <li class=md-nav__item> <a href=../../Android/Android%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E5%92%8Croot%E6%9D%83%E9%99%90/ class=md-nav__link> Android </a> </li> <li class=md-nav__item> <a href=../../Bash/%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84Linux%E6%8A%80%E5%B7%A7/ class=md-nav__link> Bash </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_2 type=checkbox id=__nav_2 checked> <label class=md-nav__link for=__nav_2> 树莓派 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=树莓派 data-md-level=1> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> 树莓派 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85Ubuntu%20mate15.10-%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0_machh%E7%9A%84%E4%B8%93%E6%A0%8F-CSDN%E5%8D%9A%E5%AE%A2/ class=md-nav__link> 树莓派安装Ubuntu mate15.10 系统笔记 machh的专栏 CSDN博客 </a> </li> <li class=md-nav__item> <a href=../%E5%B0%86%E6%A0%91%E8%8E%93%E6%B4%BERaspberry%20Pi%E8%AE%BE%E7%BD%AE%E4%B8%BA%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%28WiFi%E7%83%AD%E7%82%B9AP%2CRTL8188CUS%E8%8A%AF%E7%89%87%29/ class=md-nav__link> 将树莓派Raspberry Pi设置为无线路由器(WiFi热点AP,RTL8188CUS芯片) </a> </li> <li class=md-nav__item> <a href=../Using%20Raspberry%20Pi%20for%20Laravel%20developing/ class=md-nav__link> Using Raspberry Pi for Laravel developing </a> </li> <li class=md-nav__item> <a href=../VNC%20setup%20on%20Raspberry%20Pi%20from%20Ubuntu/ class=md-nav__link> VNC setup on Raspberry Pi from Ubuntu </a> </li> <li class=md-nav__item> <a href=../%E8%AE%BE%E7%BD%AE%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E5%A4%96%E7%BD%AE%E7%A1%AC%E7%9B%98%E5%90%AF%E5%8A%A8/ class=md-nav__link> 设置树莓派使用外置硬盘启动 </a> </li> <li class=md-nav__item> <a href=../%E6%8A%8A%E6%A0%91%E8%8E%93%E6%B4%BE%E5%8F%98%E6%88%9024%E5%B0%8F%E6%97%B6%E8%BF%90%E8%A1%8C%E7%9A%84%E4%B8%8B%E8%BD%BD%E7%A5%9E%E5%99%A8%EF%BC%88%E7%A7%8D%E5%AD%90%E3%80%81%E7%A3%81%E5%8A%9B%E9%93%BE%E9%80%9A%E9%80%9A%E6%94%AF%E6%8C%81%EF%BC%89/ class=md-nav__link> 把树莓派变成24小时运行的下载神器（种子、磁力链通通支持） </a> </li> <li class=md-nav__item> <a href=../%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE2%E4%B8%8A%E5%AE%89%E8%A3%85%20Chromium%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%8A%20Google%20%E6%8B%BC%E9%9F%B3%E8%BE%93%E5%85%A5%E6%B3%95/ class=md-nav__link> 在树莓派2上安装 Chromium 浏览器及 Google 拼音输入法 </a> </li> <li class=md-nav__item> <a href=../%E4%B8%BA%E6%A0%91%E8%8E%93%E6%B4%BEDIY%E4%B8%80%E6%AC%BE%E9%AB%98%E9%80%9F%E7%A8%B3%E5%AE%9A%E7%9A%84%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1/ class=md-nav__link> 为树莓派DIY一款高速稳定的无线网卡 </a> </li> <li class=md-nav__item> <a href=../%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B6%E2%80%94%E2%80%94%E6%A0%91%E8%8E%93%E6%B4%BE%E5%81%9Awifi%E7%83%AD%E7%82%B9_%E8%80%81%E5%BE%902014-CSDN%E5%8D%9A%E5%AE%A2_%E6%A0%91%E8%8E%93%E6%B4%BE%E5%81%9Awifi%E7%83%AD%E7%82%B9/ class=md-nav__link> 树莓派开发系列教程6——树莓派做wifi热点 老徐2014 CSDN博客 树莓派做wifi热点 </a> </li> <li class=md-nav__item> <a href=../%E6%A0%91%E8%8E%93%E6%B4%BEwifi%E7%A0%B4%E8%A7%A3%E6%95%B4%E7%90%86%20-%20FindHao/ class=md-nav__link> 树莓派wifi破解整理 FindHao </a> </li> <li class=md-nav__item> <a href=../%E6%A0%91%E8%8E%93%E6%B4%BE%E9%A6%99%E6%A9%99%E6%B4%BE%E6%97%A0%E7%BA%BF%E6%92%AD%E6%94%BE%EF%BC%8C%E5%AE%9E%E7%8E%B0DLNA%E4%B8%8EAirPlay%E5%8D%8F%E8%AE%AE%E6%97%A0%E7%BA%BF%E9%9F%B3%E7%AE%B1/ class=md-nav__link> 树莓派香橙派无线播放，实现DLNA与AirPlay协议无线音箱 </a> </li> <li class=md-nav__item> <a href=../SSH%E9%80%9A%E8%BF%87%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5/ class=md-nav__link> SSH通过代理连接 </a> </li> <li class=md-nav__item> <a href=../Autossh%20and%20Systemd%20Service/ class=md-nav__link> Autossh and Systemd Service </a> </li> <li class=md-nav__item> <a href=../Copying%20MySQL%20Databases%20to%20Another%20Machine/ class=md-nav__link> Copying MySQL Databases to Another Machine </a> </li> <li class=md-nav__item> <a href=../How%20To%20Move%20a%20MySQL%20Data%20Directory%20to%20a%20New%20Location%20on%20Ubuntu%2016.04/ class=md-nav__link> How To Move a MySQL Data Directory to a New Location on Ubuntu 16.04 </a> </li> <li class=md-nav__item> <a href=../Latest%20Version%20of%20Firefox%20and%20Thunderbird%20on%20a%20Raspberry%20Pi%20%5Bobsolete%5D/ class=md-nav__link> Latest Version of Firefox and Thunderbird on a Raspberry Pi [obsolete] </a> </li> <li class=md-nav__item> <a href=../OpenWrt%20%E4%BD%BF%E7%94%A8%20frp%20%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%20%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%20%E6%96%87%E7%AB%A0%E8%AF%84%E8%AE%BA/ class=md-nav__link> OpenWrt 使用 frp 实现内网穿透 准备工作 搭建内网穿透 文章评论 </a> </li> <li class=md-nav__item> <a href=../%E8%A7%A3%E5%86%B3%E6%A0%91%E8%8E%93%E6%B4%BESSH%E7%99%BB%E5%BD%95%E7%BC%93%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98_Maoning%20Guan%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2/ class=md-nav__link> 解决树莓派SSH登录缓慢的问题 Maoning Guan的博客 CSDN博客 </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" data-md-toggle=toc type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> Reading privileged memory with a side channel <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> Reading privileged memory with a side channel </a> <nav class="md-nav md-nav--secondary" aria-label=目录> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#reading-privileged-memory-with-a-side-channel class=md-nav__link> Reading privileged memory with a side-channel </a> </li> <li class=md-nav__item> <a href=#tested-processors class=md-nav__link> Tested Processors </a> </li> <li class=md-nav__item> <a href=#glossary class=md-nav__link> Glossary </a> </li> <li class=md-nav__item> <a href=#variant-1-bounds-check-bypass class=md-nav__link> Variant 1: Bounds check bypass </a> <nav class=md-nav aria-label="Variant 1: Bounds check bypass"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#theoretical-explanation class=md-nav__link> Theoretical explanation </a> </li> <li class=md-nav__item> <a href=#attacking-the-kernel class=md-nav__link> Attacking the kernel </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#variant-2-branch-target-injection class=md-nav__link> Variant 2: Branch target injection </a> <nav class=md-nav aria-label="Variant 2: Branch target injection"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#basics class=md-nav__link> Basics </a> </li> <li class=md-nav__item> <a href=#haswell-branch-prediction-internals class=md-nav__link> Haswell branch prediction internals </a> <nav class=md-nav aria-label="Haswell branch prediction internals"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_1 class=md-nav__link> </a> </li> <li class=md-nav__item> <a href=#_2 class=md-nav__link> </a> </li> <li class=md-nav__item> <a href=#_3 class=md-nav__link> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#reading-host-memory-from-a-kvm-guest class=md-nav__link> Reading host memory from a KVM guest </a> <nav class=md-nav aria-label="Reading host memory from a KVM guest"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_4 class=md-nav__link> </a> </li> <li class=md-nav__item> <a href=#_5 class=md-nav__link> </a> </li> <li class=md-nav__item> <a href=#_6 class=md-nav__link> </a> </li> <li class=md-nav__item> <a href=#_7 class=md-nav__link> </a> </li> <li class=md-nav__item> <a href=#_8 class=md-nav__link> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#variant-3-rogue-data-cache-load class=md-nav__link> Variant 3: Rogue data cache load </a> </li> <li class=md-nav__item> <a href=#ideas-for-further-research class=md-nav__link> Ideas for further research </a> <nav class=md-nav aria-label="Ideas for further research"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#leaking-without-data-cache-timing class=md-nav__link> Leaking without data cache timing </a> </li> <li class=md-nav__item> <a href=#other-microarchitectures class=md-nav__link> Other microarchitectures </a> </li> <li class=md-nav__item> <a href=#other-jit-engines class=md-nav__link> Other JIT engines </a> </li> <li class=md-nav__item> <a href=#more-efficient-scanning-for-host-virtual-addresses-and-cache-sets class=md-nav__link> More efficient scanning for host-virtual addresses and cache sets </a> </li> <li class=md-nav__item> <a href=#dumping-the-complete-btb-state class=md-nav__link> Dumping the complete BTB state </a> </li> <li class=md-nav__item> <a href=#variant-2-leaking-with-more-efficient-gadgets class=md-nav__link> Variant 2: Leaking with more efficient gadgets </a> </li> <li class=md-nav__item> <a href=#various-speedups class=md-nav__link> Various speedups </a> </li> <li class=md-nav__item> <a href=#leaking-or-injection-through-the-return-predictor class=md-nav__link> Leaking or injection through the return predictor </a> </li> <li class=md-nav__item> <a href=#leaking-data-out-of-the-indirect-call-predictor class=md-nav__link> Leaking data out of the indirect call predictor </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#vendor-statements class=md-nav__link> Vendor statements </a> <nav class=md-nav aria-label="Vendor statements"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#intel class=md-nav__link> Intel </a> </li> <li class=md-nav__item> <a href=#amd class=md-nav__link> AMD </a> </li> <li class=md-nav__item> <a href=#arm class=md-nav__link> ARM </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#literature class=md-nav__link> Literature </a> </li> <li class=md-nav__item> <a href=#references class=md-nav__link> References </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../Install%20Latest%20ReadyMedia%20miniDLNA%20Raspberry%20Pi/ class=md-nav__link> Install Latest ReadyMedia miniDLNA Raspberry Pi </a> </li> <li class=md-nav__item> <a href=../%E4%BD%BF%E7%94%A8%20vcgencmd%20%E6%8C%87%E4%BB%A4%E6%9F%A5%E7%9C%8B%20Raspberry%20Pi%20%E7%9A%84%20CPU%20%E6%BA%AB%E5%BA%A6%E3%80%81%E9%81%8B%E8%A1%8C%E9%80%9F%E5%BA%A6%E8%88%87%E9%9B%BB%E5%A3%93%E7%AD%89%E8%B3%87%E8%A8%8A/ class=md-nav__link> 使用 vcgencmd 指令查看 Raspberry Pi 的 CPU 溫度、運行速度與電壓等資訊 </a> </li> <li class=md-nav__item> <a href=../Aria2%20%E7%BC%96%E8%AF%91%20%E6%B7%BB%E5%8A%A0%E6%94%AF%E6%8C%81BT%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%88X86%E5%92%8Carmhf%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE2%EF%BC%89/ class=md-nav__link> Aria2 编译 添加支持BT下载的功能（X86和armhf的树莓派2） </a> </li> <li class=md-nav__item> <a href=../Let%27s%20Encrypt%EF%BC%8C%E5%85%8D%E8%B4%B9%E5%A5%BD%E7%94%A8%E7%9A%84%20HTTPS%20%E8%AF%81%E4%B9%A6/ class=md-nav__link> Let's Encrypt，免费好用的 HTTPS 证书 </a> </li> <li class=md-nav__item> <a href=../%E4%BD%BF%E7%94%A8SSH%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/ class=md-nav__link> 使用SSH反向隧道进行内网穿透 </a> </li> <li class=md-nav__item> <a href=../%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%A9%E7%94%A8nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%8C%E6%88%90%E4%B8%BAIPv6_IPv4%E5%85%AC%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E9%9C%80%E8%A6%81%E8%BF%9C%E7%A8%8B%E5%8F%8C%E6%A0%88%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89/ class=md-nav__link> 树莓派利用nginx反向代理，成为IPv6 IPv4公网服务器（需要远程双栈服务器） </a> </li> <li class=md-nav__item> <a href=../%E5%A6%82%E4%BD%95%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E6%90%AD%E5%BB%BA%20WordPress/ class=md-nav__link> 如何在树莓派上搭建 WordPress </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_3 type=checkbox id=__nav_3> <label class=md-nav__link for=__nav_3> Android <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Android data-md-level=1> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> Android </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../Android/Android%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E5%92%8Croot%E6%9D%83%E9%99%90/ class=md-nav__link> Android系统权限和root权限 </a> </li> <li class=md-nav__item> <a href=../../Android/%E3%80%90Android%20ROM%E5%AE%9A%E5%88%B6%E3%80%91CyanogenMod%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E5%92%8C%E7%BC%96%E8%AF%91/ class=md-nav__link> 【Android ROM定制】CyanogenMod源码下载和编译 </a> </li> <li class=md-nav__item> <a href=../../Android/android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/ class=md-nav__link> Android内存泄露优化总结 </a> </li> <li class=md-nav__item> <a href=../../Android/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF%EF%BC%9AProguard%E8%BF%9B%E8%A1%8C%E6%BA%90%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E5%92%8C%E5%B4%A9%E6%BA%83%E6%97%A5%E5%BF%97%E5%8F%8D%E6%B7%B7%E6%B7%86/ class=md-nav__link> 日积月累：Proguard进行源代码混淆和崩溃日志反混淆 </a> </li> <li class=md-nav__item> <a href=../../Android/10%20Ways%20to%20Improve%20Your%20Android%20App%27s%20Performance/ class=md-nav__link> 10 Ways to Improve Your Android App's Performance </a> </li> <li class=md-nav__item> <a href=../../Android/Anatomy%20of%20RecyclerView%3Aa%20Search%20for%20a%20ViewHolder/ class=md-nav__link> Anatomy of RecyclerView:a Search for a ViewHolder </a> </li> <li class=md-nav__item> <a href=../../Android/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94Hook%E6%9C%BA%E5%88%B6%E4%B9%8BBinder%20Hook/ class=md-nav__link> Android插件化原理解析——Hook机制之Binder Hook </a> </li> <li class=md-nav__item> <a href=../../Android/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%BD%93%E5%BE%AE%E4%BF%A1%E8%BF%90%E5%8A%A8%E7%AC%AC%E4%B8%80%E5%90%8D%E2%80%93%E5%88%A9%E7%94%A8AndroidHook%E8%BF%9B%E8%A1%8C%E5%BE%AE%E4%BF%A1%E8%BF%90%E5%8A%A8%E4%BD%9C%E5%BC%8A/ class=md-nav__link> 手把手教你当微信运动第一名–利用AndroidHook进行微信运动作弊 </a> </li> <li class=md-nav__item> <a href=../../Android/%E9%BB%91%E5%AE%A2%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E4%B8%89%E6%98%9F%E9%A2%84%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9D%A5%E7%9B%91%E8%A7%86%E7%94%A8%E6%88%B7/ class=md-nav__link> 黑客可以利用三星预装的应用程序来监视用户 </a> </li> <li class=md-nav__item> <a href=../../Android/Android%20%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93%20Android%20%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/ class=md-nav__link> Android 动画总结 Android 动画总结 </a> </li> <li class=md-nav__item> <a href=../../Android/Android%E7%AD%BE%E5%90%8D%E6%80%BB%E7%BB%93/ class=md-nav__link> Android签名总结 </a> </li> <li class=md-nav__item> <a href=../../Android/Am%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95/ class=md-nav__link> Am命令用法 </a> </li> <li class=md-nav__item> <a href=../../Android/10%20Tips%20for%20using%20the%20Eclipse%20Memory%20Analyzer/ class=md-nav__link> 10 Tips for using the Eclipse Memory Analyzer </a> </li> <li class=md-nav__item> <a href=../../Android/android%E4%BD%BF%E7%94%A8ndk-stack%E8%B0%83%E8%AF%95JNI%E9%83%A8%E5%88%86%E7%9A%84C_C%2B%2B%E4%BB%A3%E7%A0%81/ class=md-nav__link> android使用ndk stack调试JNI部分的C C++代码 </a> </li> <li class=md-nav__item> <a href=../../Android/NativeActivity%E5%8E%9F%E7%90%86/ class=md-nav__link> NativeActivity原理 </a> </li> <li class=md-nav__item> <a href=../../Android/Using%20data%20binding%20in%20Android/ class=md-nav__link> Using data binding in Android </a> </li> <li class=md-nav__item> <a href=../../Android/Android%E4%B8%8AWebRTC%E4%BB%8B%E7%BB%8D/ class=md-nav__link> Android上WebRTC介绍 </a> </li> <li class=md-nav__item> <a href=../../Android/CoordinatorLayout%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95-%E8%87%AA%E5%AE%9A%E4%B9%89Behavior/ class=md-nav__link> CoordinatorLayout高级用法 自定义Behavior </a> </li> <li class=md-nav__item> <a href=../../Android/OpenSSL%E5%AE%9E%E8%B7%B5-Android%E4%B8%8B%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E4%BD%BF%E7%94%A8/ class=md-nav__link> OpenSSL实践 Android下的编译和使用 </a> </li> <li class=md-nav__item> <a href=../../Android/%E4%BD%BF%E7%94%A8ShareSDK%E5%AE%8C%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%EF%BC%88QQ%E3%80%81%E5%BE%AE%E4%BF%A1%E3%80%81%E5%BE%AE%E5%8D%9A%EF%BC%89%E7%99%BB%E5%BD%95%E5%92%8C%E5%88%86%E4%BA%AB/ class=md-nav__link> 使用ShareSDK完成第三方（QQ、微信、微博）登录和分享 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_4 type=checkbox id=__nav_4> <label class=md-nav__link for=__nav_4> Bash <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Bash data-md-level=1> <label class=md-nav__title for=__nav_4> <span class="md-nav__icon md-icon"></span> Bash </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../Bash/%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84Linux%E6%8A%80%E5%B7%A7/ class=md-nav__link> 应该知道的Linux技巧 </a> </li> <li class=md-nav__item> <a href=../../Bash/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%9ATmux%20%E7%BB%88%E7%AB%AF%E5%A4%8D%E7%94%A8/ class=md-nav__link> 优雅地使用命令行：Tmux 终端复用 </a> </li> <li class=md-nav__item> <a href=../../Bash/%E6%88%91%E7%9A%84ImageMagick%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/ class=md-nav__link> 我的ImageMagick使用心得 </a> </li> <li class=md-nav__item> <a href=../../Bash/gdbcomm/ class=md-nav__link> Gdbcomm </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_5 type=checkbox id=__nav_5> <label class=md-nav__link for=__nav_5> Python <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Python data-md-level=1> <label class=md-nav__title for=__nav_5> <span class="md-nav__icon md-icon"></span> Python </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../Python/python%E5%88%B6%E4%BD%9Cpdf%E7%94%B5%E5%AD%90%E4%B9%A6/ class=md-nav__link> Python制作pdf电子书 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../../%E7%AE%97%E6%B3%95/ class=md-nav__link> 算法 </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_7 type=checkbox id=__nav_7> <label class=md-nav__link for=__nav_7> 安全 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=安全 data-md-level=1> <label class=md-nav__title for=__nav_7> <span class="md-nav__icon md-icon"></span> 安全 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../other/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/ class=md-nav__link> 缓冲区溢出攻击实验 </a> </li> <li class=md-nav__item> <a href=../../other/%E5%B7%A7%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/ class=md-nav__link> 巧用命令注入的N种方式 </a> </li> <li class=md-nav__item> <a href=../../other/Smashing%20the%20Stack%20for%20Fun%20and%20Profit%20by%20Aleph%20One/ class=md-nav__link> Smashing the Stack for Fun and Profit by Aleph One </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_8 type=checkbox id=__nav_8> <label class=md-nav__link for=__nav_8> 其它 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=其它 data-md-level=1> <label class=md-nav__title for=__nav_8> <span class="md-nav__icon md-icon"></span> 其它 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../other/TOP%2011%20Deep%20Web%20Search%20Engine%20Alternative%20for%20Google%20and%20Bing%202021/ class=md-nav__link> TOP 11 Deep Web Search Engine Alternative for Google and Bing 2021 </a> </li> <li class=md-nav__item> <a href=../../other/FFmpeg%E5%8A%9F%E8%83%BD%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/ class=md-nav__link> FFmpeg功能命令汇总 </a> </li> <li class=md-nav__item> <a href=../../other/%E4%B8%8D%E6%80%95%E5%A5%B8%E5%95%86%20%E6%8F%AD%E5%90%84%E5%93%81%E7%89%8C%E7%94%B5%E8%A7%86%E8%BF%9B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%96%B9%E6%B3%95/ class=md-nav__link> 不怕奸商 揭各品牌电视进工厂模式方法 </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label=目录> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#reading-privileged-memory-with-a-side-channel class=md-nav__link> Reading privileged memory with a side-channel </a> </li> <li class=md-nav__item> <a href=#tested-processors class=md-nav__link> Tested Processors </a> </li> <li class=md-nav__item> <a href=#glossary class=md-nav__link> Glossary </a> </li> <li class=md-nav__item> <a href=#variant-1-bounds-check-bypass class=md-nav__link> Variant 1: Bounds check bypass </a> <nav class=md-nav aria-label="Variant 1: Bounds check bypass"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#theoretical-explanation class=md-nav__link> Theoretical explanation </a> </li> <li class=md-nav__item> <a href=#attacking-the-kernel class=md-nav__link> Attacking the kernel </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#variant-2-branch-target-injection class=md-nav__link> Variant 2: Branch target injection </a> <nav class=md-nav aria-label="Variant 2: Branch target injection"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#basics class=md-nav__link> Basics </a> </li> <li class=md-nav__item> <a href=#haswell-branch-prediction-internals class=md-nav__link> Haswell branch prediction internals </a> <nav class=md-nav aria-label="Haswell branch prediction internals"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_1 class=md-nav__link> </a> </li> <li class=md-nav__item> <a href=#_2 class=md-nav__link> </a> </li> <li class=md-nav__item> <a href=#_3 class=md-nav__link> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#reading-host-memory-from-a-kvm-guest class=md-nav__link> Reading host memory from a KVM guest </a> <nav class=md-nav aria-label="Reading host memory from a KVM guest"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_4 class=md-nav__link> </a> </li> <li class=md-nav__item> <a href=#_5 class=md-nav__link> </a> </li> <li class=md-nav__item> <a href=#_6 class=md-nav__link> </a> </li> <li class=md-nav__item> <a href=#_7 class=md-nav__link> </a> </li> <li class=md-nav__item> <a href=#_8 class=md-nav__link> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#variant-3-rogue-data-cache-load class=md-nav__link> Variant 3: Rogue data cache load </a> </li> <li class=md-nav__item> <a href=#ideas-for-further-research class=md-nav__link> Ideas for further research </a> <nav class=md-nav aria-label="Ideas for further research"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#leaking-without-data-cache-timing class=md-nav__link> Leaking without data cache timing </a> </li> <li class=md-nav__item> <a href=#other-microarchitectures class=md-nav__link> Other microarchitectures </a> </li> <li class=md-nav__item> <a href=#other-jit-engines class=md-nav__link> Other JIT engines </a> </li> <li class=md-nav__item> <a href=#more-efficient-scanning-for-host-virtual-addresses-and-cache-sets class=md-nav__link> More efficient scanning for host-virtual addresses and cache sets </a> </li> <li class=md-nav__item> <a href=#dumping-the-complete-btb-state class=md-nav__link> Dumping the complete BTB state </a> </li> <li class=md-nav__item> <a href=#variant-2-leaking-with-more-efficient-gadgets class=md-nav__link> Variant 2: Leaking with more efficient gadgets </a> </li> <li class=md-nav__item> <a href=#various-speedups class=md-nav__link> Various speedups </a> </li> <li class=md-nav__item> <a href=#leaking-or-injection-through-the-return-predictor class=md-nav__link> Leaking or injection through the return predictor </a> </li> <li class=md-nav__item> <a href=#leaking-data-out-of-the-indirect-call-predictor class=md-nav__link> Leaking data out of the indirect call predictor </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#vendor-statements class=md-nav__link> Vendor statements </a> <nav class=md-nav aria-label="Vendor statements"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#intel class=md-nav__link> Intel </a> </li> <li class=md-nav__item> <a href=#amd class=md-nav__link> AMD </a> </li> <li class=md-nav__item> <a href=#arm class=md-nav__link> ARM </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#literature class=md-nav__link> Literature </a> </li> <li class=md-nav__item> <a href=#references class=md-nav__link> References </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h2 id=reading-privileged-memory-with-a-side-channel>Reading privileged memory with a side-channel</h2> <p>Posted by Jann Horn, Project Zero</p> <p>We have discovered that CPU data cache timing can be abused to efficiently leak information out of mis-speculated execution, leading to (at worst) arbitrary virtual memory read vulnerabilities across local security boundaries in various contexts.</p> <p>Variants of this issue are known to affect many modern processors, including certain processors by Intel, AMD and ARM. For a few Intel and AMD CPU models, we have exploits that work against real software. We reported this issue to Intel, AMD and ARM on 2017-06-01 [1].</p> <p>So far, there are three known variants of the issue:</p> <ul> <li>Variant 1: bounds check bypass (CVE-2017-5753)</li> <li>Variant 2: branch target injection (CVE-2017-5715)</li> <li>Variant 3: rogue data cache load (CVE-2017-5754)</li> </ul> <p>Before the issues described here were publicly disclosed, Daniel Gruss, Moritz Lipp, Yuval Yarom, Paul Kocher, Daniel Genkin, Michael Schwarz, Mike Hamburg, Stefan Mangard, Thomas Prescher and Werner Haas also reported them; their [writeups/blogposts/paper drafts] are at:</p> <ul> <li><a href=https://spectreattack.com/spectre.pdf>Spectre</a> (variants 1 and 2)</li> <li><a href=https://meltdownattack.com/meltdown.pdf>Meltdown</a> (variant 3)</li> </ul> <p>During the course of our research, we developed the following proofs of concept (PoCs):</p> <ol> <li>A PoC that demonstrates the basic principles behind variant 1 in userspace on the tested Intel Haswell Xeon CPU, the AMD FX CPU, the AMD PRO CPU and an ARM Cortex A57 [2]. This PoC only tests for the ability to read data inside mis-speculated execution within the same process, without crossing any privilege boundaries.</li> <li>A PoC for variant 1 that, when running with normal user privileges under a modern Linux kernel with a distro-standard config, can perform arbitrary reads in a 4GiB range [3] in kernel virtual memory on the Intel Haswell Xeon CPU. If the kernel's BPF JIT is enabled (non-default configuration), it also works on the AMD PRO CPU. On the Intel Haswell Xeon CPU, kernel virtual memory can be read at a rate of around 2000 bytes per second after around 4 seconds of startup time. [4]</li> <li>A PoC for variant 2 that, when running with root privileges inside a KVM guest created using virt-manager on the Intel Haswell Xeon CPU, with a specific (now outdated) version of Debian's distro kernel [5] running on the host, can read host kernel memory at a rate of around 1500 bytes/second, with room for optimization. Before the attack can be performed, some initialization has to be performed that takes roughly between 10 and 30 minutes for a machine with 64GiB of RAM; the needed time should scale roughly linearly with the amount of host RAM. (If 2MB hugepages are available to the guest, the initialization should be much faster, but that hasn't been tested.)</li> <li>A PoC for variant 3 that, when running with normal user privileges, can read kernel memory on the Intel Haswell Xeon CPU under some precondition. We believe that this precondition is that the targeted kernel memory is present in the L1D cache.</li> </ol> <p>For interesting resources around this topic, look down into the "Literature" section.</p> <p>A warning regarding explanations about processor internals in this blogpost: This blogpost contains a lot of speculation about hardware internals based on observed behavior, which might not necessarily correspond to what processors are actually doing.</p> <p>We have some ideas on possible mitigations and provided some of those ideas to the processor vendors; however, we believe that the processor vendors are in a much better position than we are to design and evaluate mitigations, and we expect them to be the source of authoritative guidance.</p> <p>The PoC code and the writeups that we sent to the CPU vendors are available here: <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1272">https://bugs.chromium.org/p/project-zero/issues/detail?id=1272</a>.</p> <h1 id=tested-processors>Tested Processors</h1> <ul> <li>Intel(R) Xeon(R) CPU E5-1650 v3 @ 3.50GHz (called "Intel Haswell Xeon CPU" in the rest of this document)</li> <li>AMD FX(tm)-8320 Eight-Core Processor (called "AMD FX CPU" in the rest of this document)</li> <li>AMD PRO A8-9600 R7, 10 COMPUTE CORES 4C+6G (called "AMD PRO CPU" in the rest of this document)</li> <li>An ARM Cortex A57 core of a Google Nexus 5x phone [6] (called "ARM Cortex A57" in the rest of this document)</li> </ul> <h1 id=glossary>Glossary</h1> <p>retire: An instruction retires when its results, e.g. register writes and memory writes, are committed and made visible to the rest of the system. Instructions can be executed out of order, but must always retire in order.</p> <p>logical processor core: A logical processor core is what the operating system sees as a processor core. With hyperthreading enabled, the number of logical cores is a multiple of the number of physical cores.</p> <p>cached/uncached data: In this blogpost, "uncached" data is data that is only present in main memory, not in any of the cache levels of the CPU. Loading uncached data will typically take over 100 cycles of CPU time.</p> <p>speculative execution: A processor can execute past a branch without knowing whether it will be taken or where its target is, therefore executing instructions before it is known whether they should be executed. If this speculation turns out to have been incorrect, the CPU can discard the resulting state without architectural effects and continue execution on the correct execution path. Instructions do not retire before it is known that they are on the correct execution path.</p> <p>mis-speculation window: The time window during which the CPU speculatively executes the wrong code and has not yet detected that mis-speculation has occurred.</p> <h1 id=variant-1-bounds-check-bypass>Variant 1: Bounds check bypass</h1> <p>This section explains the common theory behind all three variants and the theory behind our PoC for variant 1 that, when running in userspace under a Debian distro kernel, can perform arbitrary reads in a 4GiB region of kernel memory in at least the following configurations:</p> <ul> <li>Intel Haswell Xeon CPU, eBPF JIT is off (default state)</li> <li>Intel Haswell Xeon CPU, eBPF JIT is on (non-default state)</li> <li>AMD PRO CPU, eBPF JIT is on (non-default state)</li> </ul> <p>The state of the eBPF JIT can be toggled using the net.core.bpf_jit_enable sysctl.</p> <h2 id=theoretical-explanation>Theoretical explanation</h2> <p>The <a href=https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf>Intel Optimization Reference Manual</a> says the following regarding Sandy Bridge (and later microarchitectural revisions) in section 2.3.2.3 ("Branch Prediction"):</p> <p>Branch prediction predicts the branch target and enables the</p> <p>processor to begin executing instructions long before the branch</p> <p>true execution path is known.</p> <p>In section 2.3.5.2 ("L1 DCache"):</p> <p>Loads can:</p> <p>[...] * Be carried out speculatively, before preceding branches are resolved. * Take cache misses out of order and in an overlapped manner.</p> <p>Intel's Software Developer's Manual [7] states in Volume 3A, section 11.7 ("Implicit Caching (Pentium 4, Intel Xeon, and P6 family processors"):</p> <p>Implicit caching occurs when a memory element is made potentially cacheable, although the element may never have been accessed in the normal von Neumann sequence. Implicit caching occurs on the P6 and more recent processor families due to aggressive prefetching, branch prediction, and TLB miss handling. Implicit caching is an extension of the behavior of existing Intel386, Intel486, and Pentium processor systems, since software running on these processor families also has not been able to deterministically predict the behavior of instruction prefetch.</p> <p>Consider the code sample below. If arr1-&gt;length is uncached, the processor can speculatively load data from arr1-&gt;data[untrusted_offset_from_caller]. This is an out-of-bounds read. That should not matter because the processor will effectively roll back the execution state when the branch has executed; none of the speculatively executed instructions will retire (e.g. cause registers etc. to be affected).</p> <p>struct array {</p> <p>unsigned long length;</p> <p>unsigned char data[];</p> <p>};</p> <p>struct array *arr1 = ...;</p> <p>unsigned long untrusted_offset_from_caller = ...;</p> <p>if (untrusted_offset_from_caller &lt; arr1-&gt;length) {</p> <p>unsigned char value = arr1-&gt;data[untrusted_offset_from_caller];</p> <p>...</p> <p>}</p> <p>However, in the following code sample, there's an issue. If arr1-&gt;length, arr2-&gt;data[0x200] and arr2-&gt;data[0x300] are not cached, but all other accessed data is, and the branch conditions are predicted as true, the processor can do the following speculatively before arr1-&gt;length has been loaded and the execution is re-steered:</p> <ul> <li>load value = arr1-&gt;data[untrusted_offset_from_caller]</li> <li>start a load from a data-dependent offset in arr2-&gt;data, loading the corresponding cache line into the L1 cache</li> </ul> <p>struct array {</p> <p>unsigned long length;</p> <p>unsigned char data[];</p> <p>};</p> <p>struct array <em>arr1 = ...; /</em> small array */</p> <p>struct array <em>arr2 = ...; /</em> array of size 0x400 */</p> <p>/<em> &gt;0x400 (OUT OF BOUNDS!) </em>/</p> <p>unsigned long untrusted_offset_from_caller = ...;</p> <p>if (untrusted_offset_from_caller &lt; arr1-&gt;length) {</p> <p>unsigned char value = arr1-&gt;data[untrusted_offset_from_caller];</p> <p>unsigned long index2 = ((value&amp;1)*0x100)+0x200;</p> <p>if (index2 &lt; arr2-&gt;length) {</p> <p>unsigned char value2 = arr2-&gt;data[index2];</p> <p>}</p> <p>}</p> <p>After the execution has been returned to the non-speculative path because the processor has noticed that untrusted_offset_from_caller is bigger than arr1-&gt;length, the cache line containing arr2-&gt;data[index2] stays in the L1 cache. By measuring the time required to load arr2-&gt;data[0x200] and arr2-&gt;data[0x300], an attacker can then determine whether the value of index2 during speculative execution was 0x200 or 0x300 - which discloses whether arr1-&gt;data[untrusted_offset_from_caller]&amp;1 is 0 or 1.</p> <p>To be able to actually use this behavior for an attack, an attacker needs to be able to cause the execution of such a vulnerable code pattern in the targeted context with an out-of-bounds index. For this, the vulnerable code pattern must either be present in existing code, or there must be an interpreter or JIT engine that can be used to generate the vulnerable code pattern. So far, we have not actually identified any existing, exploitable instances of the vulnerable code pattern; the PoC for leaking kernel memory using variant 1 uses the eBPF interpreter or the eBPF JIT engine, which are built into the kernel and accessible to normal users.</p> <p>A minor variant of this could be to instead use an out-of-bounds read to a function pointer to gain control of execution in the mis-speculated path. We did not investigate this variant further.</p> <h2 id=attacking-the-kernel>Attacking the kernel</h2> <p>This section describes in more detail how variant 1 can be used to leak Linux kernel memory using the eBPF bytecode interpreter and JIT engine. While there are many interesting potential targets for variant 1 attacks, we chose to attack the Linux in-kernel eBPF JIT/interpreter because it provides more control to the attacker than most other JITs.</p> <p>The Linux kernel supports eBPF since version 3.18. Unprivileged userspace code can supply bytecode to the kernel that is verified by the kernel and then:</p> <ul> <li>either interpreted by an in-kernel bytecode interpreter</li> <li>or translated to native machine code that also runs in kernel context using a JIT engine (which translates individual bytecode instructions without performing any further optimizations)</li> </ul> <p>Execution of the bytecode can be triggered by attaching the eBPF bytecode to a socket as a filter and then sending data through the other end of the socket.</p> <p>Whether the JIT engine is enabled depends on a run-time configuration setting - but at least on the tested Intel processor, the attack works independent of that setting.</p> <p>Unlike classic BPF, eBPF has data types like data arrays and function pointer arrays into which eBPF bytecode can index. Therefore, it is possible to create the code pattern described above in the kernel using eBPF bytecode.</p> <p>eBPF's data arrays are less efficient than its function pointer arrays, so the attack will use the latter where possible.</p> <p>Both machines on which this was tested have no SMAP, and the PoC relies on that (but it shouldn't be a precondition in principle).</p> <p>Additionally, at least on the Intel machine on which this was tested, bouncing modified cache lines between cores is slow, apparently because the MESI protocol is used for cache coherence [8]. Changing the reference counter of an eBPF array on one physical CPU core causes the cache line containing the reference counter to be bounced over to that CPU core, making reads of the reference counter on all other CPU cores slow until the changed reference counter has been written back to memory. Because the length and the reference counter of an eBPF array are stored in the same cache line, this also means that changing the reference counter on one physical CPU core causes reads of the eBPF array's length to be slow on other physical CPU cores (intentional false sharing).</p> <p>The attack uses two eBPF programs. The first one tail-calls through a page-aligned eBPF function pointer array prog_map at a configurable index. In simplified terms, this program is used to determine the address of prog_map by guessing the offset from prog_map to a userspace address and tail-calling through prog_map at the guessed offsets. To cause the branch prediction to predict that the offset is below the length of prog_map, tail calls to an in-bounds index are performed in between. To increase the mis-speculation window, the cache line containing the length of prog_map is bounced to another core. To test whether an offset guess was successful, it can be tested whether the userspace address has been loaded into the cache.</p> <p>Because such straightforward brute-force guessing of the address would be slow, the following optimization is used: 215 adjacent userspace memory mappings [9], each consisting of 24 pages, are created at the userspace address user_mapping_area, covering a total area of 231 bytes. Each mapping maps the same physical pages, and all mappings are present in the pagetables.</p> <p><a href=https://3.bp.blogspot.com/-64YRnkgMujY/Wk064WtrSRI/AAAAAAAACPg/O4ZxlUiWerACL61P490xrVMWSmHTwQflQCEwYBhgL/s1600/image3.png><img alt src=http://i.vjob.top:8000/imgs/20220303_image3.png></a></p> <p>This permits the attack to be carried out in steps of 231 bytes. For each step, after causing an out-of-bounds access through prog_map, only one cache line each from the first 24 pages of user_mapping_area have to be tested for cached memory. Because the L3 cache is physically indexed, any access to a virtual address mapping a physical page will cause all other virtual addresses mapping the same physical page to become cached as well.</p> <p>When this attack finds a hit—a cached memory location—the upper 33 bits of the kernel address are known (because they can be derived from the address guess at which the hit occurred), and the low 16 bits of the address are also known (from the offset inside user_mapping_area at which the hit was found). The remaining part of the address of user_mapping_area is the middle.</p> <p><a href=https://1.bp.blogspot.com/-kSdcfy3GVSw/Wk065qWZZaI/AAAAAAAACPs/7HRZEXij3rIqvAf4gq8QpyHKvJsT2pYIQCEwYBhgL/s1600/image5.png><img alt src=http://i.vjob.top:8000/imgs/20220303_image5.png></a></p> <p>The remaining bits in the middle can be determined by bisecting the remaining address space: Map two physical pages to adjacent ranges of virtual addresses, each virtual address range the size of half of the remaining search space, then determine the remaining address bit-wise.</p> <p>At this point, a second eBPF program can be used to actually leak data. In pseudocode, this program looks as follows:</p> <p>uint64_t bitmask = <runtime-configurable>;</p> <p>uint64_t bitshift_selector = <runtime-configurable>;</p> <p>uint64_t prog_array_base_offset = <runtime-configurable>;</p> <p>uint64_t secret_data_offset = <runtime-configurable>;</p> <p>// index will be bounds-checked by the runtime,</p> <p>// but the bounds check will be bypassed speculatively</p> <p>uint64_t secret_data = bpf_map_read(array=victim_array, index=secret_data_offset);</p> <p>// select a single bit, move it to a specific position, and add the base offset</p> <p>uint64_t progmap_index = (((secret_data &amp; bitmask) &gt;&gt; bitshift_selector) &lt;&lt; 7) + prog_array_base_offset;</p> <p>bpf_tail_call(prog_map, progmap_index);</p> <p>This program reads 8-byte-aligned 64-bit values from an eBPF data array "victim_map" at a runtime-configurable offset and bitmasks and bit-shifts the value so that one bit is mapped to one of two values that are 27 bytes apart (sufficient to not land in the same or adjacent cache lines when used as an array index). Finally it adds a 64-bit offset, then uses the resulting value as an offset into prog_map for a tail call.</p> <p>This program can then be used to leak memory by repeatedly calling the eBPF program with an out-of-bounds offset into victim_map that specifies the data to leak and an out-of-bounds offset into prog_map that causes prog_map + offset to point to a userspace memory area. Misleading the branch prediction and bouncing the cache lines works the same way as for the first eBPF program, except that now, the cache line holding the length of victim_map must also be bounced to another core.</p> <h1 id=variant-2-branch-target-injection>Variant 2: Branch target injection</h1> <p>This section describes the theory behind our PoC for variant 2 that, when running with root privileges inside a KVM guest created using virt-manager on the Intel Haswell Xeon CPU, with a specific version of Debian's distro kernel running on the host, can read host kernel memory at a rate of around 1500 bytes/second.</p> <h2 id=basics>Basics</h2> <p>Prior research (see the Literature section at the end) has shown that it is possible for code in separate security contexts to influence each other's branch prediction. So far, this has only been used to infer information about where code is located (in other words, to create interference from the victim to the attacker); however, the basic hypothesis of this attack variant is that it can also be used to redirect execution of code in the victim context (in other words, to create interference from the attacker to the victim; the other way around).</p> <p><a href=https://3.bp.blogspot.com/-O6-JHlkvq5U/Wk064bpm2qI/AAAAAAAACPk/rjpYr72vyF0jYASgT-w4NBFQXC3hgIZZwCEwYBhgL/s1600/image2.png><img alt src=http://i.vjob.top:8000/imgs/20220303_image2.png></a></p> <p>The basic idea for the attack is to target victim code that contains an indirect branch whose target address is loaded from memory and flush the cache line containing the target address out to main memory. Then, when the CPU reaches the indirect branch, it won't know the true destination of the jump, and it won't be able to calculate the true destination until it has finished loading the cache line back into the CPU, which takes a few hundred cycles. Therefore, there is a time window of typically over 100 cycles in which the CPU will speculatively execute instructions based on branch prediction.</p> <h2 id=haswell-branch-prediction-internals>Haswell branch prediction internals</h2> <p>Some of the internals of the branch prediction implemented by Intel's processors have already been published; however, getting this attack to work properly required significant further experimentation to determine additional details.</p> <p>This section focuses on the branch prediction internals that were experimentally derived from the Intel Haswell Xeon CPU.</p> <p>Haswell seems to have multiple branch prediction mechanisms that work very differently:</p> <ul> <li>A generic branch predictor that can only store one target per source address; used for all kinds of jumps, like absolute jumps, relative jumps and so on.</li> <li>A specialized indirect call predictor that can store multiple targets per source address; used for indirect calls.</li> <li>(There is also a specialized return predictor, according to Intel's optimization manual, but we haven't analyzed that in detail yet. If this predictor could be used to reliably dump out some of the call stack through which a VM was entered, that would be very interesting.)</li> </ul> <h3 id=_1></h3> <p>Generic predictor</p> <p>The generic branch predictor, as documented in prior research, only uses the lower 31 bits of the address of the last byte of the source instruction for its prediction. If, for example, a branch target buffer (BTB) entry exists for a jump from 0x4141.0004.1000 to 0x4141.0004.5123, the generic predictor will also use it to predict a jump from 0x4242.0004.1000. When the higher bits of the source address differ like this, the higher bits of the predicted destination change together with it—in this case, the predicted destination address will be 0x4242.0004.5123—so apparently this predictor doesn't store the full, absolute destination address.</p> <p>Before the lower 31 bits of the source address are used to look up a BTB entry, they are folded together using XOR. Specifically, the following bits are folded together:</p> <p>| bit A | bit B | | 0x40.0000 | 0x2000 | | 0x80.0000 | 0x4000 | | 0x100.0000 | 0x8000 | | 0x200.0000 | 0x1.0000 | | 0x400.0000 | 0x2.0000 | | 0x800.0000 | 0x4.0000 | | 0x2000.0000 | 0x10.0000 | | 0x4000.0000 | 0x20.0000 |</p> <p>In other words, if a source address is XORed with both numbers in a row of this table, the branch predictor will not be able to distinguish the resulting address from the original source address when performing a lookup. For example, the branch predictor is able to distinguish source addresses 0x100.0000 and 0x180.0000, and it can also distinguish source addresses 0x100.0000 and 0x180.8000, but it can't distinguish source addresses 0x100.0000 and 0x140.2000 or source addresses 0x100.0000 and 0x180.4000. In the following, this will be referred to as aliased source addresses.</p> <p>When an aliased source address is used, the branch predictor will still predict the same target as for the unaliased source address. This indicates that the branch predictor stores a truncated absolute destination address, but that hasn't been verified.</p> <p>Based on observed maximum forward and backward jump distances for different source addresses, the low 32-bit half of the target address could be stored as an absolute 32-bit value with an additional bit that specifies whether the jump from source to target crosses a 232 boundary; if the jump crosses such a boundary, bit 31 of the source address determines whether the high half of the instruction pointer should increment or decrement.</p> <h3 id=_2></h3> <p>Indirect call predictor</p> <p>The inputs of the BTB lookup for this mechanism seem to be:</p> <ul> <li>The low 12 bits of the address of the source instruction (we are not sure whether it's the address of the first or the last byte) or a subset of them.</li> <li>The branch history buffer state.</li> </ul> <p>If the indirect call predictor can't resolve a branch, it is resolved by the generic predictor instead. Intel's optimization manual hints at this behavior: "Indirect Calls and Jumps. These may either be predicted as having a monotonic target or as having targets that vary in accordance with recent program behavior."</p> <p>The branch history buffer (BHB) stores information about the last 29 taken branches - basically a fingerprint of recent control flow - and is used to allow better prediction of indirect calls that can have multiple targets.</p> <p>The update function of the BHB works as follows (in pseudocode; src is the address of the last byte of the source instruction, dst is the destination address):</p> <p>void bhb_update(uint58_t *bhb_state, unsigned long src, unsigned long dst) {</p> <p>*bhb_state &lt;&lt;= 2;</p> <p>*bhb_state ^= (dst &amp; 0x3f);</p> <p>*bhb_state ^= (src &amp; 0xc0) &gt;&gt; 6;</p> <p>*bhb_state ^= (src &amp; 0xc00) &gt;&gt; (10 - 2);</p> <p>*bhb_state ^= (src &amp; 0xc000) &gt;&gt; (14 - 4);</p> <p>*bhb_state ^= (src &amp; 0x30) &lt;&lt; (6 - 4);</p> <p>*bhb_state ^= (src &amp; 0x300) &lt;&lt; (8 - 8);</p> <p>*bhb_state ^= (src &amp; 0x3000) &gt;&gt; (12 - 10);</p> <p>*bhb_state ^= (src &amp; 0x30000) &gt;&gt; (16 - 12);</p> <p>*bhb_state ^= (src &amp; 0xc0000) &gt;&gt; (18 - 14);</p> <p>}</p> <p>Some of the bits of the BHB state seem to be folded together further using XOR when used for a BTB access, but the precise folding function hasn't been understood yet.</p> <p>The BHB is interesting for two reasons. First, knowledge about its approximate behavior is required in order to be able to accurately cause collisions in the indirect call predictor. But it also permits dumping out the BHB state at any repeatable program state at which the attacker can execute code - for example, when attacking a hypervisor, directly after a hypercall. The dumped BHB state can then be used to fingerprint the hypervisor or, if the attacker has access to the hypervisor binary, to determine the low 20 bits of the hypervisor load address (in the case of KVM: the low 20 bits of the load address of kvm-intel.ko).</p> <h3 id=_3></h3> <p>Reverse-Engineering Branch Predictor Internals</p> <p>This subsection describes how we reverse-engineered the internals of the Haswell branch predictor. Some of this is written down from memory, since we didn't keep a detailed record of what we were doing.</p> <p>We initially attempted to perform BTB injections into the kernel using the generic predictor, using the knowledge from prior research that the generic predictor only looks at the lower half of the source address and that only a partial target address is stored. This kind of worked - however, the injection success rate was very low, below 1%. (This is the method we used in our preliminary PoCs for method 2 against modified hypervisors running on Haswell.)</p> <p>We decided to write a userspace test case to be able to more easily test branch predictor behavior in different situations.</p> <p>Based on the assumption that branch predictor state is shared between hyperthreads [10], we wrote a program of which two instances are each pinned to one of the two logical processors running on a specific physical core, where one instance attempts to perform branch injections while the other measures how often branch injections are successful. Both instances were executed with ASLR disabled and had the same code at the same addresses. The injecting process performed indirect calls to a function that accesses a (per-process) test variable; the measuring process performed indirect calls to a function that tests, based on timing, whether the per-process test variable is cached, and then evicts it using CLFLUSH. Both indirect calls were performed through the same callsite. Before each indirect call, the function pointer stored in memory was flushed out to main memory using CLFLUSH to widen the speculation time window. Additionally, because of the reference to "recent program behavior" in Intel's optimization manual, a bunch of conditional branches that are always taken were inserted in front of the indirect call.</p> <p>In this test, the injection success rate was above 99%, giving us a base setup for future experiments.</p> <p><a href=https://2.bp.blogspot.com/-RMKau2Jstd0/Wk066oeGPUI/AAAAAAAACP0/sb5X95OHei0JV0xhCQDRhaYhRsLvx9ZmACEwYBhgL/s1600/image7.png><img alt src=http://i.vjob.top:8000/imgs/20220303_image7.png></a></p> <p>We then tried to figure out the details of the prediction scheme. We assumed that the prediction scheme uses a global branch history buffer of some kind.</p> <p>To determine the duration for which branch information stays in the history buffer, a conditional branch that is only taken in one of the two program instances was inserted in front of the series of always-taken conditional jumps, then the number of always-taken conditional jumps (N) was varied. The result was that for N=25, the processor was able to distinguish the branches (misprediction rate under 1%), but for N=26, it failed to do so (misprediction rate over 99%).</p> <p>Therefore, the branch history buffer had to be able to store information about at least the last 26 branches.</p> <p>The code in one of the two program instances was then moved around in memory. This revealed that only the lower 20 bits of the source and target addresses have an influence on the branch history buffer.</p> <p>Testing with different types of branches in the two program instances revealed that static jumps, taken conditional jumps, calls and returns influence the branch history buffer the same way; non-taken conditional jumps don't influence it; the address of the last byte of the source instruction is the one that counts; IRETQ doesn't influence the history buffer state (which is useful for testing because it permits creating program flow that is invisible to the history buffer).</p> <p>Moving the last conditional branch before the indirect call around in memory multiple times revealed that the branch history buffer contents can be used to distinguish many different locations of that last conditional branch instruction. This suggests that the history buffer doesn't store a list of small history values; instead, it seems to be a larger buffer in which history data is mixed together.</p> <p>However, a history buffer needs to "forget" about past branches after a certain number of new branches have been taken in order to be useful for branch prediction. Therefore, when new data is mixed into the history buffer, this can not cause information in bits that are already present in the history buffer to propagate downwards - and given that, upwards combination of information probably wouldn't be very useful either. Given that branch prediction also must be very fast, we concluded that it is likely that the update function of the history buffer left-shifts the old history buffer, then XORs in the new state (see diagram).</p> <p><a href=https://1.bp.blogspot.com/-crbBTenupqw/Wk066CBQ2qI/AAAAAAAACPw/GaUAa5tUDE8dV9tZ6bt-QWGLY5klZM5FgCEwYBhgL/s1600/image6.png><img alt src=http://i.vjob.top:8000/imgs/20220303_image6.png></a></p> <p>If this assumption is correct, then the history buffer contains a lot of information about the most recent branches, but only contains as many bits of information as are shifted per history buffer update about the last branch about which it contains any data. Therefore, we tested whether flipping different bits in the source and target addresses of a jump followed by 32 always-taken jumps with static source and target allows the branch prediction to disambiguate an indirect call. [11] </p> <p>With 32 static jumps in between, no bit flips seemed to have an influence, so we decreased the number of static jumps until a difference was observable. The result with 28 always-taken jumps in between was that bits 0x1 and 0x2 of the target and bits 0x40 and 0x80 of the source had such an influence; but flipping both 0x1 in the target and 0x40 in the source or 0x2 in the target and 0x80 in the source did not permit disambiguation. This shows that the per-insertion shift of the history buffer is 2 bits and shows which data is stored in the least significant bits of the history buffer. We then repeated this with decreased amounts of fixed jumps after the bit-flipped jump to determine which information is stored in the remaining bits.</p> <h2 id=reading-host-memory-from-a-kvm-guest>Reading host memory from a KVM guest</h2> <h3 id=_4></h3> <p>Locating the host kernel</p> <p>Our PoC locates the host kernel in several steps. The information that is determined and necessary for the next steps of the attack consists of:</p> <ul> <li>lower 20 bits of the address of kvm-intel.ko</li> <li>full address of kvm.ko</li> <li>full address of vmlinux</li> </ul> <p>Looking back, this is unnecessarily complicated, but it nicely demonstrates the various techniques an attacker can use. A simpler way would be to first determine the address of vmlinux, then bisect the addresses of kvm.ko and kvm-intel.ko.</p> <p>In the first step, the address of kvm-intel.ko is leaked. For this purpose, the branch history buffer state after guest entry is dumped out. Then, for every possible value of bits 12..19 of the load address of kvm-intel.ko, the expected lowest 16 bits of the history buffer are computed based on the load address guess and the known offsets of the last 8 branches before guest entry, and the results are compared against the lowest 16 bits of the leaked history buffer state.</p> <p>The branch history buffer state is leaked in steps of 2 bits by measuring misprediction rates of an indirect call with two targets. One way the indirect call is reached is from a vmcall instruction followed by a series of N branches whose relevant source and target address bits are all zeroes. The second way the indirect call is reached is from a series of controlled branches in userspace that can be used to write arbitrary values into the branch history buffer.</p> <p>Misprediction rates are measured as in the section "Reverse-Engineering Branch Predictor Internals", using one call target that loads a cache line and another one that checks whether the same cache line has been loaded.</p> <p><a href=https://3.bp.blogspot.com/-juuq6gYvhn4/Wk065XER9yI/AAAAAAAACPo/EuTi1HzweloKCChZajY7FUDEtHXhs12ZwCEwYBhgL/s1600/image4.png><img alt src=http://i.vjob.top:8000/imgs/20220303_image4.png></a></p> <p>With N=29, mispredictions will occur at a high rate if the controlled branch history buffer value is zero because all history buffer state from the hypercall has been erased. With N=28, mispredictions will occur if the controlled branch history buffer value is one of 0&lt;&lt;(28<em>2), 1&lt;&lt;(28</em>2), 2&lt;&lt;(28<em>2), 3&lt;&lt;(28</em>2) - by testing all four possibilities, it can be detected which one is right. Then, for decreasing values of N, the four possibilities are {0|1|2|3}&lt;&lt;(28*2) | (history_buffer_for(N+1) &gt;&gt; 2). By repeating this for decreasing values for N, the branch history buffer value for N=0 can be determined.</p> <p><a href=https://4.bp.blogspot.com/-uAWgXXpjs8I/Wk064FS-g3I/AAAAAAAACPc/0nh9nbSn0EkTXgzbbuY1TRROTR02GWIFQCEwYBhgL/s1600/image1.png><img alt src=http://i.vjob.top:8000/imgs/20220303_image1.png></a></p> <p>At this point, the low 20 bits of kvm-intel.ko are known; the next step is to roughly locate kvm.ko.</p> <p>For this, the generic branch predictor is used, using data inserted into the BTB by an indirect call from kvm.ko to kvm-intel.ko that happens on every hypercall; this means that the source address of the indirect call has to be leaked out of the BTB.</p> <p>kvm.ko will probably be located somewhere in the range from 0xffffffffc0000000 to 0xffffffffc4000000, with page alignment (0x1000). This means that the first four entries in the table in the section "Generic Predictor" apply; there will be 24-1=15 aliasing addresses for the correct one. But that is also an advantage: It cuts down the search space from 0x4000 to 0x4000/24=1024.</p> <p>To find the right address for the source or one of its aliasing addresses, code that loads data through a specific register is placed at all possible call targets (the leaked low 20 bits of kvm-intel.ko plus the in-module offset of the call target plus a multiple of 220) and indirect calls are placed at all possible call sources. Then, alternatingly, hypercalls are performed and indirect calls are performed through the different possible non-aliasing call sources, with randomized history buffer state that prevents the specialized prediction from working. After this step, there are 216 remaining possibilities for the load address of kvm.ko.</p> <p>Next, the load address of vmlinux can be determined in a similar way, using an indirect call from vmlinux to kvm.ko. Luckily, none of the bits which are randomized in the load address of vmlinux  are folded together, so unlike when locating kvm.ko, the result will directly be unique. vmlinux has an alignment of 2MiB and a randomization range of 1GiB, so there are still only 512 possible addresses.</p> <p>Because (as far as we know) a simple hypercall won't actually cause indirect calls from vmlinux to kvm.ko, we instead use port I/O from the status register of an emulated serial port, which is present in the default configuration of a virtual machine created with virt-manager.</p> <p>The only remaining piece of information is which one of the 16 aliasing load addresses of kvm.ko is actually correct. Because the source address of an indirect call to kvm.ko is known, this can be solved using bisection: Place code at the various possible targets that, depending on which instance of the code is speculatively executed, loads one of two cache lines, and measure which one of the cache lines gets loaded.</p> <h3 id=_5></h3> <p>Identifying cache sets</p> <p>The PoC assumes that the VM does not have access to hugepages.To discover eviction sets for all L3 cache sets with a specific alignment relative to a 4KiB page boundary, the PoC first allocates 25600 pages of memory. Then, in a loop, it selects random subsets of all remaining unsorted pages such that the expected number of sets for which an eviction set is contained in the subset is 1, reduces each subset down to an eviction set by repeatedly accessing its cache lines and testing whether the cache lines are always cached (in which case they're probably not part of an eviction set) and attempts to use the new eviction set to evict all remaining unsorted cache lines to determine whether they are in the same cache set [12].</p> <h3 id=_6></h3> <p>Locating the host-virtual address of a guest page</p> <p>Because this attack uses a FLUSH+RELOAD approach for leaking data, it needs to know the host-kernel-virtual address of one guest page. Alternative approaches such as PRIME+PROBE should work without that requirement.</p> <p>The basic idea for this step of the attack is to use a branch target injection attack against the hypervisor to load an attacker-controlled address and test whether that caused the guest-owned page to be loaded. For this, a gadget that simply loads from the memory location specified by R8 can be used - R8-R11 still contain guest-controlled values when the first indirect call after a guest exit is reached on this kernel build.</p> <p>We expected that an attacker would need to either know which eviction set has to be used at this point or brute-force it simultaneously; however, experimentally, using random eviction sets works, too. Our theory is that the observed behavior is actually the result of L1D and L2 evictions, which might be sufficient to permit a few instructions worth of speculative execution.</p> <p>The host kernel maps (nearly?) all physical memory in the physmap area, including memory assigned to KVM guests. However, the location of the physmap is randomized (with a 1GiB alignment), in an area of size 128PiB. Therefore, directly bruteforcing the host-virtual address of a guest page would take a long time. It is not necessarily impossible; as a ballpark estimate, it should be possible within a day or so, maybe less, assuming 12000 successful injections per second and 30 guest pages that are tested in parallel; but not as impressive as doing it in a few minutes.</p> <p>To optimize this, the problem can be split up: First, brute-force the physical address using a gadget that can load from physical addresses, then brute-force the base address of the physmap region. Because the physical address can usually be assumed to be far below 128PiB, it can be brute-forced more efficiently, and brute-forcing the base address of the physmap region afterwards is also easier because then address guesses with 1GiB alignment can be used.</p> <p>To brute-force the physical address, the following gadget can be used:</p> <p>ffffffff810a9def:       4c 89 c0                mov    rax,r8</p> <p>ffffffff810a9df2:       4d 63 f9                movsxd r15,r9d</p> <p>ffffffff810a9df5:       4e 8b 04 fd c0 b3 a6    mov    r8,QWORD PTR [r15*8-0x7e594c40]</p> <p>ffffffff810a9dfc:       81 </p> <p>ffffffff810a9dfd:       4a 8d 3c 00             lea    rdi,[rax+r8*1]</p> <p>ffffffff810a9e01:       4d 8b a4 00 f8 00 00    mov    r12,QWORD PTR [r8+rax*1+0xf8]</p> <p>ffffffff810a9e08:       00 </p> <p>This gadget permits loading an 8-byte-aligned value from the area around the kernel text section by setting R9 appropriately, which in particular permits loading page_offset_base, the start address of the physmap. Then, the value that was originally in R8 - the physical address guess minus 0xf8 - is added to the result of the previous load, 0xfa is added to it, and the result is dereferenced.</p> <h3 id=_7></h3> <p>Cache set selection</p> <p>To select the correct L3 eviction set, the attack from the following section is essentially executed with different eviction sets until it works.</p> <h3 id=_8></h3> <p>Leaking data</p> <p>At this point, it would normally be necessary to locate gadgets in the host kernel code that can be used to actually leak data by reading from an attacker-controlled location, shifting and masking the result appropriately and then using the result of that as offset to an attacker-controlled address for a load. But piecing gadgets together and figuring out which ones work in a speculation context seems annoying. So instead, we decided to use the eBPF interpreter, which is built into the host kernel - while there is no legitimate way to invoke it from inside a VM, the presence of the code in the host kernel's text section is sufficient to make it usable for the attack, just like with ordinary ROP gadgets.</p> <p>The eBPF interpreter entry point has the following function signature:</p> <p>static unsigned int __bpf_prog_run(void <em>ctx, const struct bpf_insn </em>insn)</p> <p>The second parameter is a pointer to an array of statically pre-verified eBPF instructions to be executed - which means that __bpf_prog_run() will not perform any type checks or bounds checks. The first parameter is simply stored as part of the initial emulated register state, so its value doesn't matter.</p> <p>The eBPF interpreter provides, among other things:</p> <ul> <li>multiple emulated 64-bit registers</li> <li>64-bit immediate writes to emulated registers</li> <li>memory reads from addresses stored in emulated registers</li> <li>bitwise operations (including bit shifts) and arithmetic operations</li> </ul> <p>To call the interpreter entry point, a gadget that gives RSI and RIP control given R8-R11 control and controlled data at a known memory location is necessary. The following gadget provides this functionality:</p> <p>ffffffff81514edd:       4c 89 ce                mov    rsi,r9<br> ffffffff81514ee0:       41 ff 90 b0 00 00 00    call   QWORD PTR [r8+0xb0]</p> <p>Now, by pointing R8 and R9 at the mapping of a guest-owned page in the physmap, it is possible to speculatively execute arbitrary unvalidated eBPF bytecode in the host kernel. Then, relatively straightforward bytecode can be used to leak data into the cache.</p> <h1 id=variant-3-rogue-data-cache-load>Variant 3: Rogue data cache load</h1> <p>Basically, read Anders Fogh's blogpost: <a href=https://cyber.wtf/2017/07/28/negative-result-reading-kernel-memory-from-user-mode/ >https://cyber.wtf/2017/07/28/negative-result-reading-kernel-memory-from-user-mode/</a></p> <p>In summary, an attack using this variant of the issue attempts to read kernel memory from userspace without misdirecting the control flow of kernel code. This works by using the code pattern that was used for the previous variants, but in userspace. The underlying idea is that the permission check for accessing an address might not be on the critical path for reading data from memory to a register, where the permission check could have significant performance impact. Instead, the memory read could make the result of the read available to following instructions immediately and only perform the permission check asynchronously, setting a flag in the reorder buffer that causes an exception to be raised if the permission check fails.</p> <p>We do have a few additions to make to Anders Fogh's blogpost:</p> <p>"Imagine the following instruction executed in usermode</p> <p>mov rax,[somekernelmodeaddress]</p> <p>It will cause an interrupt when retired, [...]"</p> <p>It is also possible to already execute that instruction behind a high-latency mispredicted branch to avoid taking a page fault. This might also widen the speculation window by increasing the delay between the read from a kernel address and delivery of the associated exception.</p> <p>"First, I call a syscall that touches this memory. Second, I use the prefetcht0 instruction to improve my odds of having the address loaded in L1."</p> <p>When we used prefetch instructions after doing a syscall, the attack stopped working for us, and we have no clue why. Perhaps the CPU somehow stores whether access was denied on the last access and prevents the attack from working if that is the case?</p> <p>"Fortunately I did not get a slow read suggesting that Intel null’s the result when the access is not allowed."</p> <p>That (read from kernel address returns all-zeroes) seems to happen for memory that is not sufficiently cached but for which pagetable entries are present, at least after repeated read attempts. For unmapped memory, the kernel address read does not return a result at all.</p> <h1 id=ideas-for-further-research>Ideas for further research</h1> <p>We believe that our research provides many remaining research topics that we have not yet investigated, and we encourage other public researchers to look into these.</p> <p>This section contains an even higher amount of speculation than the rest of this blogpost - it contains untested ideas that might well be useless.</p> <h2 id=leaking-without-data-cache-timing>Leaking without data cache timing</h2> <p>It would be interesting to explore whether there are microarchitectural attacks other than measuring data cache timing that can be used for exfiltrating data out of speculative execution.</p> <h2 id=other-microarchitectures>Other microarchitectures</h2> <p>Our research was relatively Haswell-centric so far. It would be interesting to see details e.g. on how the branch prediction of other modern processors works and how well it can be attacked.</p> <h2 id=other-jit-engines>Other JIT engines</h2> <p>We developed a successful variant 1 attack against the JIT engine built into the Linux kernel. It would be interesting to see whether attacks against more advanced JIT engines with less control over the system are also practical - in particular, JavaScript engines.</p> <h2 id=more-efficient-scanning-for-host-virtual-addresses-and-cache-sets>More efficient scanning for host-virtual addresses and cache sets</h2> <p>In variant 2, while scanning for the host-virtual address of a guest-owned page, it might make sense to attempt to determine its L3 cache set first. This could be done by performing L3 evictions using an eviction pattern through the physmap, then testing whether the eviction affected the guest-owned page.</p> <p>The same might work for cache sets - use an L1D+L2 eviction set to evict the function pointer in the host kernel context, use a gadget in the kernel to evict an L3 set using physical addresses, then use that to identify which cache sets guest lines belong to until a guest-owned eviction set has been constructed.</p> <h2 id=dumping-the-complete-btb-state>Dumping the complete BTB state</h2> <p>Given that the generic BTB seems to only be able to distinguish 231-8 or fewer source addresses, it seems feasible to dump out the complete BTB state generated by e.g. a hypercall in a timeframe around the order of a few hours. (Scan for jump sources, then for every discovered jump source, bisect the jump target.) This could potentially be used to identify the locations of functions in the host kernel even if the host kernel is custom-built.</p> <p>The source address aliasing would reduce the usefulness somewhat, but because target addresses don't suffer from that, it might be possible to correlate (source,target) pairs from machines with different KASLR offsets and reduce the number of candidate addresses based on KASLR being additive while aliasing is bitwise.</p> <p>This could then potentially allow an attacker to make guesses about the host kernel version or the compiler used to build it based on jump offsets or distances between functions.</p> <h2 id=variant-2-leaking-with-more-efficient-gadgets>Variant 2: Leaking with more efficient gadgets</h2> <p>If sufficiently efficient gadgets are used for variant 2, it might not be necessary to evict host kernel function pointers from the L3 cache at all; it might be sufficient to only evict them from L1D and L2. </p> <h2 id=various-speedups>Various speedups</h2> <p>In particular the variant 2 PoC is still a bit slow. This is probably partly because:</p> <ul> <li>It only leaks one bit at a time; leaking more bits at a time should be doable.</li> <li>It heavily uses IRETQ for hiding control flow from the processor.</li> </ul> <p>It would be interesting to see what data leak rate can be achieved using variant 2.</p> <h2 id=leaking-or-injection-through-the-return-predictor>Leaking or injection through the return predictor</h2> <p>If the return predictor also doesn't lose its state on a privilege level change, it might be useful for either locating the host kernel from inside a VM (in which case bisection could be used to very quickly discover the full address of the host kernel) or injecting return targets (in particular if the return address is stored in a cache line that can be flushed out by the attacker and isn't reloaded before the return instruction).</p> <p>However, we have not performed any experiments with the return predictor that yielded conclusive results so far.</p> <h2 id=leaking-data-out-of-the-indirect-call-predictor>Leaking data out of the indirect call predictor</h2> <p>We have attempted to leak target information out of the indirect call predictor, but haven't been able to make it work.</p> <h1 id=vendor-statements>Vendor statements</h1> <p>The following statement were provided to us regarding this issue from the vendors to whom Project Zero disclosed this vulnerability:</p> <h2 id=intel>Intel</h2> <p>Intel is committed to improving the overall security of computer systems. The methods described here rely on common properties of modern microprocessors. Thus, susceptibility to these methods is not limited to Intel processors, nor does it mean that a processor is working outside its intended functional specification. Intel is working closely with our ecosystem partners, as well as with other silicon vendors whose processors are affected, to design and distribute both software and hardware mitigations for these methods. </p> <p>For more information and links to useful resources, visit: </p> <p><a href="https://security-center.intel.com/advisory.aspx?intelid=INTEL-SA-00088&languageid=en-fr">https://security-center.intel.com/advisory.aspx?intelid=INTEL-SA-00088&amp;languageid=en-fr</a> </p> <p><a href=http://newsroom.intel.com/wp-content/uploads/sites/11/2018/01/Intel-Analysis-of-Speculative-Execution-Side-Channels.pdf>http://newsroom.intel.com/wp-content/uploads/sites/11/2018/01/Intel-Analysis-of-Speculative-Execution-Side-Channels.pdf</a></p> <h2 id=amd>AMD</h2> <p>AMD provided the following link: <a href=http://www.amd.com/en/corporate/speculative-execution>http://www.amd.com/en/corporate/speculative-execution</a></p> <h2 id=arm>ARM</h2> <p>Arm recognises that the speculation functionality of many modern high-performance processors, despite working as intended, can be used in conjunction with the timing of cache operations to leak some information as described in this blog. Correspondingly, Arm has developed software mitigations that we recommend be deployed.</p> <p>Specific details regarding the affected processors and mitigations can be found at this website: <a href=https://developer.arm.com/support/security-update>https://developer.arm.com/support/security-update</a></p> <p>Arm has included a detailed technical whitepaper as well as links to information from some of Arm’s architecture partners regarding their specific implementations and mitigations.</p> <h1 id=literature>Literature</h1> <p>Note that some of these documents - in particular Intel's documentation - change over time, so quotes from and references to it may not reflect the latest version of Intel's documentation.</p> <ul> <li><a href=https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf>https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf</a>: Intel's optimization manual has many interesting pieces of optimization advice that hint at relevant microarchitectural behavior; for example:</li> <li>"Placing data immediately following an indirect branch can cause a performance problem. If the data consists of all zeros, it looks like a long stream of ADDs to memory destinations and this can cause resource conflicts and slow down branch recovery. Also, data immediately following indirect branches may appear as branches to the branch predication [sic] hardware, which can branch off to execute other data pages. This can lead to subsequent self-modifying code problems."</li> <li>"Loads can:[...]Be carried out speculatively, before preceding branches are resolved."</li> <li>"Software should avoid writing to a code page in the same 1-KByte subpage that is being executed or fetching code in the same 2-KByte subpage of that is being written. In addition, sharing a page containing directly or speculatively executed code with another processor as a data page can trigger an SMC condition that causes the entire pipeline of the machine and the trace cache to be cleared. This is due to the self-modifying code condition."</li> <li>"if mapped as WB or WT, there is a potential for speculative processor reads to bring the data into the caches"</li> <li> <p>"Failure to map the region as WC may allow the line to be speculatively read into the processor caches (via the wrong path of a mispredicted branch)."</p> </li> <li> <p><a href=https://software.intel.com/en-us/articles/intel-sdm>https://software.intel.com/en-us/articles/intel-sdm</a>: Intel's Software Developer Manuals</p> </li> <li><a href=http://www.agner.org/optimize/microarchitecture.pdf>http://www.agner.org/optimize/microarchitecture.pdf</a>: Agner Fog's documentation of reverse-engineered processor behavior and relevant theory was very helpful for this research.</li> <li><a href=http://www.cs.binghamton.edu/~dima/micro16.pdf>http://www.cs.binghamton.edu/~dima/micro16.pdf</a> and <a href=https://github.com/felixwilhelm/mario_baslr>https://github.com/felixwilhelm/mario_baslr</a>: Prior research by Dmitry Evtyushkin, Dmitry Ponomarev and Nael Abu-Ghazaleh on abusing branch target buffer behavior to leak addresses that we used as a starting point for analyzing the branch prediction of Haswell processors. Felix Wilhelm's research based on this provided the basic idea behind variant 2.</li> <li><a href=https://arxiv.org/pdf/1507.06955.pdf>https://arxiv.org/pdf/1507.06955.pdf</a>: The rowhammer.js research by Daniel Gruss, Clémentine Maurice and Stefan Mangard contains information about L3 cache eviction patterns that we reused in the KVM PoC to evict a function pointer.</li> <li><a href=https://xania.org/201602/bpu-part-one>https://xania.org/201602/bpu-part-one</a>: Matt Godbolt blogged about reverse-engineering the structure of the branch predictor on Intel processors.</li> <li><a href=https://www.sophia.re/thesis.pdf>https://www.sophia.re/thesis.pdf</a>: Sophia D'Antoine wrote a thesis that shows that opcode scheduling can theoretically be used to transmit data between hyperthreads.</li> <li><a href=https://gruss.cc/files/kaiser.pdf>https://gruss.cc/files/kaiser.pdf</a>: Daniel Gruss, Moritz Lipp, Michael Schwarz, Richard Fellner, Clémentine Maurice, and Stefan Mangard wrote a paper on mitigating microarchitectural issues caused by pagetable sharing between userspace and the kernel.</li> <li><a href=https://www.jilp.org/ >https://www.jilp.org/</a>: This journal contains many articles on branch prediction.</li> <li><a href=http://blog.stuffedcow.net/2013/01/ivb-cache-replacement/ >http://blog.stuffedcow.net/2013/01/ivb-cache-replacement/</a>: This blogpost by Henry Wong investigates the L3 cache replacement policy used by Intel's Ivy Bridge architecture.</li> </ul> <h1 id=references>References</h1> <p>[1] This initial report did not contain any information about variant 3. We had discussed whether direct reads from kernel memory could work, but thought that it was unlikely. We later tested and reported variant 3 prior to the publication of Anders Fogh's work at <a href=https://cyber.wtf/2017/07/28/negative-result-reading-kernel-memory-from-user-mode/ >https://cyber.wtf/2017/07/28/negative-result-reading-kernel-memory-from-user-mode/</a>.</p> <p>[2] The precise model names are listed in the section "Tested Processors". The code for reproducing this is in the writeup_files.tar archive in our bugtracker, in the folders userland_test_x86 and userland_test_aarch64.</p> <p>[3] The attacker-controlled offset used to perform an out-of-bounds access on an array by this PoC is a 32-bit value, limiting the accessible addresses to a 4GiB window in the kernel heap area.</p> <p>[4] This PoC won't work on CPUs with SMAP support; however, that is not a fundamental limitation.</p> <p>[5] linux-image-4.9.0-3-amd64 at version 4.9.30-2+deb9u2 (available at <a href=http://snapshot.debian.org/archive/debian/20170701T224614Z/pool/main/l/linux/linux-image-4.9.0-3-amd64_4.9.30-2%2Bdeb9u2_amd64.deb>http://snapshot.debian.org/archive/debian/20170701T224614Z/pool/main/l/linux/linux-image-4.9.0-3-amd64_4.9.30-2%2Bdeb9u2_amd64.deb</a>, sha256 5f950b26aa7746d75ecb8508cc7dab19b3381c9451ee044cd2edfd6f5efff1f8, signed via <a href=http://snapshot.debian.org/archive/debian-security/20170701T114538Z/dists/stretch/updates/Release.gpg>Release.gpg</a>, <a href=http://snapshot.debian.org/archive/debian-security/20170701T114538Z/dists/stretch/updates/Release>Release</a>, <a href=http://snapshot.debian.org/archive/debian-security/20170701T114538Z/dists/stretch/updates/main/binary-amd64/Packages.xz>Packages.xz</a>); that was the current distro kernel version when I set up the machine. It is very unlikely that the PoC works with other kernel versions without changes; it contains a number of hardcoded addresses/offsets.</p> <p>[6] The phone was running an Android build from May 2017.</p> <p>[7] <a href=https://software.intel.com/en-us/articles/intel-sdm>https://software.intel.com/en-us/articles/intel-sdm</a></p> <p>[8] <a href=https://software.intel.com/en-us/articles/avoiding-and-identifying-false-sharing-among-threads>https://software.intel.com/en-us/articles/avoiding-and-identifying-false-sharing-among-threads</a>, section "background"</p> <p>[9] More than 215 mappings would be more efficient, but the kernel places a hard cap of 216 on the number of VMAs that a process can have.</p> <p>[10] Intel's optimization manual states that "In the first implementation of HT Technology, the physical execution resources are shared and the architecture state is duplicated for each logical processor", so it would be plausible for predictor state to be shared. While predictor state could be tagged by logical core, that would likely reduce performance for multithreaded processes, so it doesn't seem likely.</p> <p>[11] In case the history buffer was a bit bigger than we had measured, we added some margin - in particular because we had seen slightly different history buffer lengths in different experiments, and because 26 isn't a very round number.</p> <p>[12] The basic idea comes from <a href=http://palms.ee.princeton.edu/system/files/SP_vfinal.pdf>http://palms.ee.princeton.edu/system/files/SP_vfinal.pdf</a>, section IV, although the authors of that paper still used hugepages.</p> <p>原文链接： <a href=https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html>https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html</a></p> </article> </div> </div> </main> <footer class=md-footer> <nav class="md-footer__inner md-grid" aria-label=页脚> <a href=../%E8%A7%A3%E5%86%B3%E6%A0%91%E8%8E%93%E6%B4%BESSH%E7%99%BB%E5%BD%95%E7%BC%93%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98_Maoning%20Guan%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2/ class="md-footer__link md-footer__link--prev" aria-label="上一页: 解决树莓派SSH登录缓慢的问题 Maoning Guan的博客 CSDN博客" rel=prev> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </div> <div class=md-footer__title> <div class=md-ellipsis> <span class=md-footer__direction> 上一页 </span> 解决树莓派SSH登录缓慢的问题 Maoning Guan的博客 CSDN博客 </div> </div> </a> <a href=../Install%20Latest%20ReadyMedia%20miniDLNA%20Raspberry%20Pi/ class="md-footer__link md-footer__link--next" aria-label="下一页: Install Latest ReadyMedia miniDLNA Raspberry Pi" rel=next> <div class=md-footer__title> <div class=md-ellipsis> <span class=md-footer__direction> 下一页 </span> Install Latest ReadyMedia miniDLNA Raspberry Pi </div> </div> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg> </div> </a> </nav> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> <div class=md-copyright__highlight> Copyright &copy; 2022 - 3022 <span style=float:right><a href=http://beian.miit.gov.cn/ >鄂ICP备19027194号-2</a></span> </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../..", "features": ["navigation.tabs", "navigation.tabs.sticky", "search.suggest", "search.highlight", "search.share"], "translations": {"clipboard.copy": "\u590d\u5236", "clipboard.copied": "\u5df2\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\uff0c\\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.term.missing": "\u7f3a\u5c11", "select.version.title": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "search": "../../assets/javascripts/workers/search.bd0b6b67.min.js"}</script> <script src=../../assets/javascripts/bundle.8aa65030.min.js></script> <script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script> </body> </html>